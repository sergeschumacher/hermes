<%- include('layouts/main', { title: 'Live TV', body: `
<div class="p-6 lg:p-8">
    <!-- Header -->
    <div class="flex flex-col lg:flex-row lg:items-center justify-between gap-4 mb-8">
        <div>
            <h1 class="text-3xl font-bold text-white">Live TV</h1>
            <p class="text-gray-400 mt-1" id="page-subtitle">Select a category to browse channels</p>
        </div>
        <div class="flex items-center gap-3">
            <button id="back-btn" class="btn btn-secondary hidden">
                <svg class="w-4 h-4 mr-2" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 19l-7-7m0 0l7-7m-7 7h18" />
                </svg>
                Back to Categories
            </button>
            <span class="text-gray-400 text-sm"><span id="results-count" class="text-white font-semibold">0</span> <span id="results-label">categories</span></span>
        </div>
    </div>

    <!-- Search Bar and Country Filter -->
    <div class="card p-4 mb-6">
        <div class="flex flex-wrap gap-4">
            <div class="flex-1 relative">
                <svg class="absolute left-4 top-1/2 -translate-y-1/2 w-5 h-5 text-gray-500" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" />
                </svg>
                <input type="text" id="search-input" placeholder="Search channels or categories..." class="input input-search" />
            </div>
            <select id="country-filter" class="input w-auto min-w-[180px]">
                <option value="">All Countries</option>
            </select>
        </div>
    </div>

    <!-- Categories Grid (initial view) -->
    <div id="categories-view">
        <div class="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-5 xl:grid-cols-6 gap-4" id="categories-grid">
        </div>
    </div>

    <!-- Channels Grid (shown when category selected) -->
    <div id="channels-view" class="hidden">
        <div class="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-6 xl:grid-cols-8 gap-4" id="channels-grid">
        </div>
        <div class="mt-8 text-center">
            <button id="load-more" class="btn btn-secondary hidden">Load More</button>
        </div>
    </div>

    <!-- Empty State -->
    <div class="empty-state hidden" id="empty-state">
        <div class="empty-state-icon">
            <svg class="w-8 h-8 text-gray-500" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M6 20.25h12m-7.5-3v3m3-3v3m-10.125-3h17.25c.621 0 1.125-.504 1.125-1.125V4.875c0-.621-.504-1.125-1.125-1.125H3.375c-.621 0-1.125.504-1.125 1.125v11.25c0 .621.504 1.125 1.125 1.125z" />
            </svg>
        </div>
        <p class="empty-state-title">No channels found</p>
        <p class="empty-state-text">Try a different search term</p>
    </div>

    <!-- Video Player Modal -->
    <div id="player-modal" class="fixed inset-0 bg-black/90 z-50 hidden flex items-center justify-center">
        <div class="relative w-full max-w-6xl mx-4">
            <!-- Close button -->
            <button id="player-close" class="absolute -top-12 right-0 text-white hover:text-gray-300 transition-colors z-10">
                <svg class="w-8 h-8" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
                </svg>
            </button>

            <!-- Channel info -->
            <div class="flex items-center gap-4 mb-4">
                <img id="player-logo" src="" alt="" class="w-12 h-12 rounded-lg object-contain bg-dark-700" onerror="this.src='/static/img/no-logo.png'" />
                <div class="flex-1 min-w-0">
                    <h2 id="player-title" class="text-xl font-bold text-white"></h2>
                    <p id="player-category" class="text-gray-400 text-sm"></p>
                    <!-- EPG Now Playing -->
                    <div id="player-epg" class="hidden mt-2">
                        <div class="flex items-center gap-2 text-sm">
                            <span class="text-primary-400 font-medium">Now:</span>
                            <span id="player-epg-now" class="text-white truncate"></span>
                            <span id="player-epg-time" class="text-gray-500 flex-shrink-0"></span>
                        </div>
                        <div class="mt-1 h-1 bg-dark-600 rounded-full overflow-hidden">
                            <div id="player-epg-progress" class="h-full bg-primary-500 transition-all" style="width: 0%"></div>
                        </div>
                        <div id="player-epg-next-wrapper" class="hidden mt-2">
                            <div class="flex items-center gap-2 text-sm text-gray-400">
                                <span>Next:</span>
                                <span id="player-epg-next" class="truncate"></span>
                                <span id="player-epg-next-time" class="flex-shrink-0"></span>
                            </div>
                        </div>
                    </div>
                </div>
                <button id="player-copy-url" class="flex-shrink-0 btn btn-secondary text-sm">
                    <svg class="w-4 h-4 mr-2" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z" />
                    </svg>
                    Copy URL
                </button>
            </div>

            <!-- Video container -->
            <div class="relative bg-black rounded-lg overflow-hidden" style="aspect-ratio: 16/9;">
                <video id="player-video" class="w-full h-full" controls autoplay playsinline>
                    Your browser does not support the video tag.
                </video>

                <!-- Loading spinner -->
                <div id="player-loading" class="absolute inset-0 flex items-center justify-center bg-black/50">
                    <div class="animate-spin rounded-full h-12 w-12 border-4 border-primary-500 border-t-transparent"></div>
                </div>

                <!-- Error state -->
                <div id="player-error" class="absolute inset-0 flex flex-col items-center justify-center bg-black/80 hidden">
                    <svg class="w-16 h-16 text-red-500 mb-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z" />
                    </svg>
                    <p class="text-white text-lg mb-2">Failed to load stream</p>
                    <p id="player-error-msg" class="text-gray-400 text-sm mb-4"></p>
                    <button id="player-retry" class="btn btn-primary">Retry</button>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- HLS.js for streaming -->
<script src="https://cdn.jsdelivr.net/npm/hls.js@latest"></script>

<script>
    let currentOffset = 0;
    const limit = 100;
    let loading = false;
    let currentCategory = null;
    let allCategories = [];
    let currentCountry = '';
    let preferredLanguages = []; // From settings

    // Country names for display
    const countryNames = {
        'DE': 'Germany', 'US': 'United States', 'UK': 'United Kingdom', 'FR': 'France',
        'ES': 'Spain', 'IT': 'Italy', 'NL': 'Netherlands', 'PL': 'Poland',
        'TR': 'Turkey', 'PT': 'Portugal', 'GR': 'Greece', 'RU': 'Russia',
        'AT': 'Austria', 'CH': 'Switzerland', 'BE': 'Belgium', 'CA': 'Canada',
        'AU': 'Australia', 'BR': 'Brazil', 'MX': 'Mexico', 'AR': 'Argentina',
        'IN': 'India', 'JP': 'Japan', 'KR': 'South Korea', 'CN': 'China',
        'SE': 'Sweden', 'NO': 'Norway', 'DK': 'Denmark', 'FI': 'Finland',
        'RO': 'Romania', 'HU': 'Hungary', 'CZ': 'Czech Republic', 'SK': 'Slovakia',
        'HR': 'Croatia', 'RS': 'Serbia', 'BG': 'Bulgaria', 'UA': 'Ukraine',
        'AL': 'Albania', 'IR': 'Iran', 'IL': 'Israel', 'SA': 'Saudi Arabia',
        'AE': 'UAE', 'EG': 'Egypt', 'ZA': 'South Africa', 'NG': 'Nigeria',
        'LA': 'Latin America', 'EU': 'Europe', 'AF': 'Africa', 'IA': 'India/Asia',
        'IE': 'Ireland', 'OTHER': 'Other'
    };

    // Extract a friendly display name from category
    function getCategoryDisplayName(category) {
        if (!category) return 'Uncategorized';
        // Remove common prefixes like |DE|, DE|, etc.
        let name = category.replace(/^\\|?[A-Z]{2}\\|\\s*/i, '');
        // Clean up special characters
        name = name.replace(/[|#]+/g, ' ').trim();
        return name || category;
    }

    // Get country code from category for flag display
    function getCategoryCountry(category) {
        if (!category) return null;
        const match = category.match(/\\|?([A-Z]{2})\\|/i) || category.match(/^([A-Z]{2})\\s/i);
        return match ? match[1].toUpperCase() : null;
    }

    // Get a representative icon for the category
    function getCategoryIcon(category) {
        const country = getCategoryCountry(category);
        if (country) {
            // Return flag emoji based on country code
            const flags = {
                'DE': '\u{1F1E9}\u{1F1EA}', 'US': '\u{1F1FA}\u{1F1F8}', 'UK': '\u{1F1EC}\u{1F1E7}', 'FR': '\u{1F1EB}\u{1F1F7}',
                'ES': '\u{1F1EA}\u{1F1F8}', 'IT': '\u{1F1EE}\u{1F1F9}', 'NL': '\u{1F1F3}\u{1F1F1}', 'PL': '\u{1F1F5}\u{1F1F1}',
                'TR': '\u{1F1F9}\u{1F1F7}', 'PT': '\u{1F1F5}\u{1F1F9}', 'GR': '\u{1F1EC}\u{1F1F7}', 'RU': '\u{1F1F7}\u{1F1FA}',
                'AT': '\u{1F1E6}\u{1F1F9}', 'CH': '\u{1F1E8}\u{1F1ED}', 'BE': '\u{1F1E7}\u{1F1EA}', 'CA': '\u{1F1E8}\u{1F1E6}',
                'AU': '\u{1F1E6}\u{1F1FA}', 'BR': '\u{1F1E7}\u{1F1F7}', 'MX': '\u{1F1F2}\u{1F1FD}', 'AR': '\u{1F1E6}\u{1F1F7}',
                'IN': '\u{1F1EE}\u{1F1F3}', 'JP': '\u{1F1EF}\u{1F1F5}', 'KR': '\u{1F1F0}\u{1F1F7}', 'CN': '\u{1F1E8}\u{1F1F3}',
                'SE': '\u{1F1F8}\u{1F1EA}', 'NO': '\u{1F1F3}\u{1F1F4}', 'DK': '\u{1F1E9}\u{1F1F0}', 'FI': '\u{1F1EB}\u{1F1EE}',
                'RO': '\u{1F1F7}\u{1F1F4}', 'HU': '\u{1F1ED}\u{1F1FA}', 'CZ': '\u{1F1E8}\u{1F1FF}', 'SK': '\u{1F1F8}\u{1F1F0}',
                'HR': '\u{1F1ED}\u{1F1F7}', 'RS': '\u{1F1F7}\u{1F1F8}', 'BG': '\u{1F1E7}\u{1F1EC}', 'UA': '\u{1F1FA}\u{1F1E6}',
                'AL': '\u{1F1E6}\u{1F1F1}', 'IR': '\u{1F1EE}\u{1F1F7}', 'IL': '\u{1F1EE}\u{1F1F1}', 'SA': '\u{1F1F8}\u{1F1E6}',
                'AE': '\u{1F1E6}\u{1F1EA}', 'EG': '\u{1F1EA}\u{1F1EC}', 'ZA': '\u{1F1FF}\u{1F1E6}', 'NG': '\u{1F1F3}\u{1F1EC}',
                'LA': '\u{1F1F1}\u{1F1E6}', 'AF': '\u{1F30D}'
            };
            return flags[country] || '\u{1F4FA}';
        }
        return '\u{1F4FA}'; // TV emoji as default
    }

    async function loadCategories() {
        try {
            // Load settings to get preferred languages
            const settingsResp = await fetch('/api/settings');
            const settings = await settingsResp.json();
            preferredLanguages = (settings.preferredLanguages || []).map(l => l.toUpperCase());

            const response = await fetch('/api/filters?type=live');
            const filters = await response.json();
            allCategories = filters.categories.filter(cat => cat);

            // Filter categories to only show preferred countries
            if (preferredLanguages.length > 0) {
                allCategories = allCategories.filter(cat => {
                    const country = getCategoryCountry(cat);
                    return country && preferredLanguages.includes(country);
                });
            }

            populateCountryFilter();
            applyFilters();
        } catch (err) {
            console.error('Failed to load categories:', err);
        }
    }

    function populateCountryFilter() {
        const select = document.getElementById('country-filter');
        // Get unique countries from categories
        const countries = new Set();
        allCategories.forEach(cat => {
            const country = getCategoryCountry(cat);
            if (country) countries.add(country);
        });

        // Sort countries with priority ones first
        const priority = ['DE', 'US', 'UK', 'FR', 'ES', 'IT'];
        const sortedCountries = Array.from(countries).sort((a, b) => {
            const aIdx = priority.indexOf(a);
            const bIdx = priority.indexOf(b);
            if (aIdx !== -1 && bIdx !== -1) return aIdx - bIdx;
            if (aIdx !== -1) return -1;
            if (bIdx !== -1) return 1;
            return a.localeCompare(b);
        });

        // Clear and repopulate
        select.innerHTML = '<option value="">All Countries</option>';
        sortedCountries.forEach(code => {
            const flag = getCategoryIcon({ match: () => [null, code] }.match() ? code : '|' + code + '|');
            const name = countryNames[code] || code;
            const option = document.createElement('option');
            option.value = code;
            option.textContent = getCategoryIcon('|' + code + '|') + ' ' + name;
            select.appendChild(option);
        });
    }

    function applyFilters() {
        const query = document.getElementById('search-input').value.toLowerCase();
        let filtered = allCategories;

        // Filter by country
        if (currentCountry) {
            filtered = filtered.filter(cat => getCategoryCountry(cat) === currentCountry);
        }

        // Filter by search query
        if (query) {
            filtered = filtered.filter(cat =>
                cat.toLowerCase().includes(query) ||
                getCategoryDisplayName(cat).toLowerCase().includes(query)
            );
        }

        renderCategories(filtered);
    }

    function renderCategories(categories) {
        const grid = document.getElementById('categories-grid');
        grid.innerHTML = '';

        // Group categories by country/region
        const grouped = {};
        categories.forEach(cat => {
            const country = getCategoryCountry(cat) || 'OTHER';
            if (!grouped[country]) grouped[country] = [];
            grouped[country].push(cat);
        });

        // Sort countries alphabetically, but put common ones first
        const priority = ['DE', 'US', 'UK', 'FR', 'ES', 'IT'];
        const sortedCountries = Object.keys(grouped).sort((a, b) => {
            const aIdx = priority.indexOf(a);
            const bIdx = priority.indexOf(b);
            if (aIdx !== -1 && bIdx !== -1) return aIdx - bIdx;
            if (aIdx !== -1) return -1;
            if (bIdx !== -1) return 1;
            if (a === 'OTHER') return 1;
            if (b === 'OTHER') return -1;
            return a.localeCompare(b);
        });

        // Render each category
        sortedCountries.forEach(country => {
            grouped[country].forEach(cat => {
                const card = document.createElement('div');
                card.className = 'card p-4 text-center hover:bg-dark-700 transition-all cursor-pointer hover:scale-105 hover:border-primary-500';
                const icon = getCategoryIcon(cat);
                const displayName = getCategoryDisplayName(cat);
                const channelCount = ''; // Could add count later

                card.innerHTML = \`
                    <div class="text-4xl mb-3">\${icon}</div>
                    <h3 class="font-medium text-white text-sm truncate" title="\${cat}">\${displayName}</h3>
                    <p class="text-gray-500 text-xs mt-1">\${country !== 'OTHER' ? country : ''}</p>
                \`;
                card.onclick = () => selectCategory(cat);
                grid.appendChild(card);
            });
        });

        document.getElementById('results-count').textContent = categories.length;
        document.getElementById('results-label').textContent = 'categories';
    }

    function selectCategory(category) {
        currentCategory = category;
        currentOffset = 0;

        // Update UI
        document.getElementById('categories-view').classList.add('hidden');
        document.getElementById('channels-view').classList.remove('hidden');
        document.getElementById('back-btn').classList.remove('hidden');
        document.getElementById('page-subtitle').textContent = getCategoryDisplayName(category);
        document.getElementById('results-label').textContent = 'channels';
        document.getElementById('search-input').placeholder = 'Search in ' + getCategoryDisplayName(category) + '...';
        document.getElementById('search-input').value = '';

        loadChannels(true);
    }

    function showCategories() {
        currentCategory = null;
        currentOffset = 0;

        // Update UI
        document.getElementById('categories-view').classList.remove('hidden');
        document.getElementById('channels-view').classList.add('hidden');
        document.getElementById('back-btn').classList.add('hidden');
        document.getElementById('page-subtitle').textContent = 'Select a category to browse channels';
        document.getElementById('results-label').textContent = 'categories';
        document.getElementById('search-input').placeholder = 'Search channels or categories...';
        document.getElementById('search-input').value = '';
        document.getElementById('empty-state').classList.add('hidden');

        applyFilters();
    }

    async function loadChannels(reset = false) {
        if (loading) return;
        loading = true;

        if (reset) {
            currentOffset = 0;
            document.getElementById('channels-grid').innerHTML = '';
        }

        const params = new URLSearchParams({
            type: 'live',
            search: document.getElementById('search-input').value,
            category: currentCategory || '',
            limit,
            offset: currentOffset
        });

        try {
            const response = await fetch('/api/media?' + params);
            const channels = await response.json();
            const grid = document.getElementById('channels-grid');
            const emptyState = document.getElementById('empty-state');

            if (reset) grid.innerHTML = '';

            if (channels.length === 0 && currentOffset === 0) {
                emptyState.classList.remove('hidden');
                grid.classList.add('hidden');
            } else {
                emptyState.classList.add('hidden');
                grid.classList.remove('hidden');
            }

            channels.forEach((channel, index) => {
                const card = document.createElement('div');
                card.className = 'card p-4 text-center hover:bg-dark-700 transition-all cursor-pointer group';
                const imgSrc = channel.poster ? proxyImage(channel.poster) : '/static/img/no-logo.png';
                const isEager = currentOffset === 0 && index < 16;

                // Clean channel name - remove country prefix
                let displayName = channel.title;
                displayName = displayName.replace(/^[A-Z]{2}\\s*[-:]\\s*/i, '');

                card.innerHTML = \`
                    <div class="relative">
                        <img src="\${isEager ? imgSrc : '/static/img/no-logo.png'}"
                             data-src="\${imgSrc}"
                             alt="\${displayName}"
                             class="w-16 h-16 mx-auto rounded-lg object-contain bg-dark-700 mb-3 \${isEager ? '' : 'lazy-image'}"
                             onerror="this.src='/static/img/no-logo.png'" />
                        <div class="absolute inset-0 flex items-center justify-center opacity-0 group-hover:opacity-100 transition-opacity">
                            <div class="bg-primary-500 rounded-full p-2">
                                <svg class="w-4 h-4 text-white" fill="currentColor" viewBox="0 0 24 24">
                                    <path d="M8 5v14l11-7z"/>
                                </svg>
                            </div>
                        </div>
                    </div>
                    <h3 class="font-medium text-white text-sm truncate" title="\${channel.title}">\${displayName}</h3>
                    <p class="text-xs text-gray-500 truncate mt-1 epg-now" data-tvg-id="\${channel.tvg_id || ''}">&nbsp;</p>
                \`;
                card.onclick = () => playChannel(channel);
                grid.appendChild(card);
            });

            initLazyLoad();

            // Fetch EPG data for channels with tvg_id
            const tvgIds = channels.filter(c => c.tvg_id).map(c => c.tvg_id);
            if (tvgIds.length > 0) {
                fetchEpgForChannels(tvgIds);
            }

            document.getElementById('results-count').textContent = (currentOffset + channels.length).toLocaleString();
            document.getElementById('load-more').classList.toggle('hidden', channels.length < limit);
            if (channels.length === limit) currentOffset += limit;
        } catch (err) {
            console.error('Failed to load channels:', err);
        }
        loading = false;
    }

    // Player state
    let hls = null;
    let currentPlayingChannel = null;

    function playChannel(channel) {
        currentPlayingChannel = channel;
        const url = channel.stream_url;

        // For .ts streams, open in VLC via server
        if (url.endsWith('.ts')) {
            // Call server API to open VLC
            fetch('/api/play', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ url })
            })
            .then(res => res.json())
            .then(data => {
                if (data.success && window.showToast) {
                    showToast('Opening in VLC...', 'success');
                } else if (data.error && window.showToast) {
                    showToast('Failed to open VLC: ' + data.error, 'error');
                }
            })
            .catch(err => {
                console.error('Failed to open VLC:', err);
                if (window.showToast) {
                    showToast('Failed to open VLC', 'error');
                }
            });
            return;
        }

        // For other streams, use the built-in player
        const modal = document.getElementById('player-modal');
        const loading = document.getElementById('player-loading');
        const error = document.getElementById('player-error');

        // Update channel info
        const imgSrc = channel.poster ? proxyImage(channel.poster) : '/static/img/no-logo.png';
        document.getElementById('player-logo').src = imgSrc;
        document.getElementById('player-title').textContent = channel.title;
        document.getElementById('player-category').textContent = channel.category || '';

        // Reset EPG display
        document.getElementById('player-epg').classList.add('hidden');

        // Reset states
        loading.classList.remove('hidden');
        error.classList.add('hidden');

        // Show modal
        modal.classList.remove('hidden');
        document.body.style.overflow = 'hidden';

        // Load stream
        loadStream(url);

        // Fetch and display EPG data
        if (channel.tvg_id) {
            fetchEpgForPlayer(channel).then(epgData => {
                if (epgData && epgData.current) {
                    updatePlayerEpg(epgData);
                }
            });
        }
    }

    function loadStream(url) {
        const video = document.getElementById('player-video');
        const loading = document.getElementById('player-loading');
        const error = document.getElementById('player-error');

        console.log('Loading stream:', url);

        // Cleanup previous instance
        if (hls) {
            hls.destroy();
            hls = null;
        }

        // Check if it's an HLS stream (.m3u8 only - raw .ts streams are NOT HLS)
        const isHls = url.includes('.m3u8');

        if (isHls && Hls.isSupported()) {
            hls = new Hls({
                enableWorker: true,
                lowLatencyMode: true,
                backBufferLength: 90
            });

            hls.loadSource(url);
            hls.attachMedia(video);

            hls.on(Hls.Events.MANIFEST_PARSED, () => {
                loading.classList.add('hidden');
                video.play().catch(e => console.log('Autoplay prevented:', e));
            });

            hls.on(Hls.Events.ERROR, (event, data) => {
                console.error('HLS error:', data);
                if (data.fatal) {
                    switch (data.type) {
                        case Hls.ErrorTypes.NETWORK_ERROR:
                            showPlayerError('Network error - stream may be offline');
                            break;
                        case Hls.ErrorTypes.MEDIA_ERROR:
                            hls.recoverMediaError();
                            break;
                        default:
                            showPlayerError('Failed to load stream');
                            break;
                    }
                }
            });
        } else if (video.canPlayType('application/vnd.apple.mpegurl')) {
            // Native HLS support (Safari)
            video.src = url;
            video.addEventListener('loadedmetadata', () => {
                loading.classList.add('hidden');
                video.play().catch(e => console.log('Autoplay prevented:', e));
            }, { once: true });
            video.addEventListener('error', () => {
                showPlayerError('Failed to load stream');
            }, { once: true });
        } else {
            // Raw .ts streams can't be played in browser - show helpful message
            if (url.endsWith('.ts')) {
                loading.classList.add('hidden');
                showPlayerError('This stream format (.ts) requires an external player like VLC. Use "Copy URL" to open in VLC.');
            } else {
                // Try direct playback for other non-HLS streams
                video.src = url;
                video.addEventListener('loadedmetadata', () => {
                    loading.classList.add('hidden');
                    video.play().catch(e => console.log('Autoplay prevented:', e));
                }, { once: true });
                video.addEventListener('error', () => {
                    showPlayerError('Stream format not supported');
                }, { once: true });
            }
        }
    }

    function showPlayerError(message) {
        const loading = document.getElementById('player-loading');
        const error = document.getElementById('player-error');
        const errorMsg = document.getElementById('player-error-msg');

        loading.classList.add('hidden');
        error.classList.remove('hidden');
        errorMsg.textContent = message;
    }

    function closePlayer() {
        const modal = document.getElementById('player-modal');
        const video = document.getElementById('player-video');

        // Stop playback
        if (hls) {
            hls.destroy();
            hls = null;
        }
        video.pause();
        video.src = '';

        // Hide modal
        modal.classList.add('hidden');
        document.body.style.overflow = '';
        currentPlayingChannel = null;
    }

    // Player event listeners
    document.getElementById('player-close').addEventListener('click', closePlayer);
    document.getElementById('player-modal').addEventListener('click', (e) => {
        if (e.target.id === 'player-modal') closePlayer();
    });
    document.getElementById('player-retry').addEventListener('click', () => {
        if (currentPlayingChannel) {
            document.getElementById('player-loading').classList.remove('hidden');
            document.getElementById('player-error').classList.add('hidden');
            loadStream(currentPlayingChannel.stream_url);
        }
    });
    document.getElementById('player-copy-url').addEventListener('click', () => {
        if (currentPlayingChannel) {
            navigator.clipboard.writeText(currentPlayingChannel.stream_url).then(() => {
                if (window.showToast) {
                    showToast('Stream URL copied to clipboard!', 'success');
                }
            });
        }
    });

    // Close on Escape key
    document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape' && !document.getElementById('player-modal').classList.contains('hidden')) {
            closePlayer();
        }
    });

    // Search handler - searches both categories and channels
    document.getElementById('search-input').addEventListener('input', debounce((e) => {
        if (currentCategory) {
            // In channel view - search channels
            loadChannels(true);
        } else {
            // In category view - apply filters
            applyFilters();
        }
    }, 300));

    // Country filter handler
    document.getElementById('country-filter').addEventListener('change', (e) => {
        currentCountry = e.target.value;
        if (currentCategory) {
            // If viewing channels, go back to categories with filter
            showCategories();
        } else {
            applyFilters();
        }
    });

    document.getElementById('back-btn').addEventListener('click', showCategories);
    document.getElementById('load-more').addEventListener('click', () => loadChannels(false));

    // EPG functions
    async function fetchEpgForChannels(tvgIds) {
        try {
            const response = await fetch('/api/epg/channels', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ channelIds: tvgIds })
            });
            const epgData = await response.json();

            // Update channel cards with EPG info
            document.querySelectorAll('.epg-now').forEach(el => {
                const tvgId = el.dataset.tvgId;
                if (tvgId && epgData[tvgId]?.current) {
                    el.textContent = epgData[tvgId].current.title;
                    el.title = epgData[tvgId].current.title;
                }
            });
        } catch (err) {
            console.error('Failed to fetch EPG:', err);
        }
    }

    async function fetchEpgForPlayer(channel) {
        if (!channel.tvg_id) return null;
        try {
            const response = await fetch(\`/api/epg/channel/\${encodeURIComponent(channel.tvg_id)}\`);
            return await response.json();
        } catch (err) {
            console.error('Failed to fetch EPG for player:', err);
            return null;
        }
    }

    function formatEpgTime(dateStr) {
        if (!dateStr) return '';
        const date = new Date(dateStr);
        return date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
    }

    function formatEpgProgress(start, end) {
        if (!start || !end) return 0;
        const now = new Date();
        const startDate = new Date(start);
        const endDate = new Date(end);
        const total = endDate - startDate;
        const elapsed = now - startDate;
        return Math.min(100, Math.max(0, (elapsed / total) * 100));
    }

    function updatePlayerEpg(epgData) {
        const epgContainer = document.getElementById('player-epg');
        const current = epgData.current;

        if (!current) {
            epgContainer.classList.add('hidden');
            return;
        }

        // Show current program
        document.getElementById('player-epg-now').textContent = current.title;
        const startTime = formatEpgTime(current.start_time);
        const endTime = formatEpgTime(current.end_time);
        document.getElementById('player-epg-time').textContent = \`\${startTime} - \${endTime}\`;

        // Update progress bar
        const progress = formatEpgProgress(current.start_time, current.end_time);
        document.getElementById('player-epg-progress').style.width = progress + '%';

        // Show next program if available
        const nextWrapper = document.getElementById('player-epg-next-wrapper');
        if (epgData.upcoming && epgData.upcoming.length > 0) {
            const next = epgData.upcoming[0];
            document.getElementById('player-epg-next').textContent = next.title;
            document.getElementById('player-epg-next-time').textContent = formatEpgTime(next.start_time);
            nextWrapper.classList.remove('hidden');
        } else {
            nextWrapper.classList.add('hidden');
        }

        epgContainer.classList.remove('hidden');
    }

    // Initialize
    loadCategories();

    function debounce(func, wait) {
        let timeout;
        return function(e) {
            clearTimeout(timeout);
            timeout = setTimeout(() => func(e), wait);
        };
    }
</script>
` }) %>
