<%- include('layouts/main', { title: 'EPG Guide', body: `
<div class="epg-page">
    <!-- Header Bar -->
    <div class="epg-header">
        <div class="epg-header-left">
            <h1 class="text-xl font-bold text-white">TV Guide</h1>
        </div>
        <div class="epg-header-center">
            <button onclick="scrollTime(-6)" class="epg-nav-btn" title="Back 6 hours">&laquo;</button>
            <button onclick="scrollTime(-1)" class="epg-nav-btn" title="Back 1 hour">&lsaquo;</button>
            <span id="current-date" class="epg-date"></span>
            <button onclick="scrollTime(1)" class="epg-nav-btn" title="Forward 1 hour">&rsaquo;</button>
            <button onclick="scrollTime(6)" class="epg-nav-btn" title="Forward 6 hours">&raquo;</button>
        </div>
        <div class="epg-header-right">
            <button onclick="goToNow()" class="btn btn-primary btn-sm">Live</button>
        </div>
    </div>

    <!-- Filter Bar -->
    <div class="epg-filter-bar">
        <div class="epg-search-wrapper">
            <svg class="epg-search-icon" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" />
            </svg>
            <input type="text" id="epg-search" class="epg-search-input" placeholder="Search channels or programs..." oninput="handleSearch(this.value)" />
            <button id="clear-search-btn" class="epg-clear-btn hidden" onclick="clearSearch()">
                <svg class="w-4 h-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
                </svg>
            </button>
        </div>
        <div class="epg-country-wrapper">
            <select id="epg-country-filter" class="select" onchange="handleCountryChange(this.value)">
                <option value="">All Countries</option>
            </select>
        </div>
        <div class="epg-time-range">
            <label class="time-range-label">Time Range:</label>
            <input type="time" id="time-start" class="time-input" onchange="handleTimeRangeChange()" />
            <span class="time-range-separator">â€“</span>
            <input type="time" id="time-end" class="time-input" onchange="handleTimeRangeChange()" />
            <button onclick="resetTimeRange()" class="btn btn-secondary btn-sm time-reset-btn" title="Reset to default">Reset</button>
        </div>
        <div id="epg-filter-info" class="epg-filter-info"></div>
    </div>

    <!-- EPG Grid -->
    <div class="epg-grid-container">
        <!-- Time Header Row -->
        <div class="epg-timeline-row">
            <div class="epg-channel-cell epg-corner"></div>
            <div class="epg-timeline" id="time-header">
                <!-- Time slots generated by JS -->
            </div>
        </div>

        <!-- Channel Rows Container -->
        <div class="epg-rows-container" id="epg-rows-container">
            <!-- Channel rows generated by JS -->
        </div>

        <!-- Loading Overlay -->
        <div id="epg-loading" class="epg-loading">
            <div class="epg-loading-spinner"></div>
            <p>Loading TV Guide...</p>
        </div>
    </div>

</div>

<!-- Recordings Section - Fixed at bottom -->
<div class="epg-recordings">
    <h2 class="text-lg font-semibold text-white mb-3">Scheduled Recordings</h2>
    <div id="recordings-list" class="recordings-list">
        <p class="text-dark-400 text-sm">No recordings scheduled</p>
    </div>
</div>

<!-- Program Detail Modal -->
<div id="program-modal" class="fixed inset-0 bg-black/70 hidden items-center justify-center z-50">
    <div class="card w-full max-w-lg mx-4">
        <div class="p-4 border-b border-dark-700 flex justify-between items-center">
            <h3 class="text-lg font-semibold text-white" id="modal-program-title">Program Details</h3>
            <button onclick="closeModal()" class="text-dark-400 hover:text-white">
                <svg class="w-6 h-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
                </svg>
            </button>
        </div>
        <div class="p-4 space-y-3">
            <div id="modal-program-channel" class="text-sm text-primary-400"></div>
            <div id="modal-program-time" class="text-sm text-dark-400"></div>
            <div id="modal-program-category" class="text-xs text-dark-500"></div>
            <p id="modal-program-description" class="text-dark-300 text-sm"></p>
        </div>

        <!-- Source Selection for Recording -->
        <div class="p-4 border-t border-dark-700" id="source-selection-container" style="display:none;">
            <label class="block text-sm font-medium text-dark-300 mb-2">Select source to record from:</label>
            <select id="source-select" class="select">
                <option value="">-- Select a source --</option>
            </select>
            <p id="no-source-msg" class="text-yellow-500 text-sm mt-2" style="display:none;">
                No matching live channels found for this EPG channel.
            </p>
        </div>

        <div class="p-4 border-t border-dark-700 flex justify-end gap-2">
            <button onclick="closeModal()" class="btn btn-secondary">Close</button>
            <button onclick="playInBrowser()" class="btn btn-info" id="play-browser-btn" style="display:none;">
                <svg class="w-4 h-4 mr-1" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 12a9 9 0 01-9 9m9-9a9 9 0 00-9-9m9 9H3m9 9a9 9 0 01-9-9m9 9c1.657 0 3-4.03 3-9s-1.343-9-3-9m0 18c-1.657 0-3-4.03-3-9s1.343-9 3-9m-9 9a9 9 0 019-9" />
                </svg>
                Browser
            </button>
            <button onclick="playInVLC()" class="btn btn-success" id="play-vlc-btn" style="display:none;">
                <svg class="w-4 h-4 mr-1" fill="currentColor" viewBox="0 0 20 20">
                    <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM9.555 7.168A1 1 0 008 8v4a1 1 0 001.555.832l3-2a1 1 0 000-1.664l-3-2z" clip-rule="evenodd" />
                </svg>
                VLC
            </button>
            <button onclick="playInVlcExtension()" class="btn btn-secondary" id="play-vlc-ext-btn" style="display:none;">
                VLC Ext
            </button>
            <button onclick="scheduleRecording()" class="btn btn-primary" id="record-btn">
                <svg class="w-4 h-4 mr-1" fill="currentColor" viewBox="0 0 20 20">
                    <circle cx="10" cy="10" r="6" fill="currentColor" />
                </svg>
                Record
            </button>
        </div>
    </div>
</div>

<style>
    .epg-page {
        display: flex;
        flex-direction: column;
        height: calc(100vh - 64px - 100px);
        background: var(--dark-bg, #0A0A0A);
        overflow: hidden;
    }

    /* Header */
    .epg-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 12px 16px;
        background: var(--dark-card, #141414);
        border-bottom: 1px solid var(--dark-border, #2D2D2D);
        flex-shrink: 0;
    }

    .epg-header-left, .epg-header-right {
        width: 120px;
    }

    .epg-header-center {
        display: flex;
        align-items: center;
        gap: 8px;
    }

    .epg-nav-btn {
        width: 32px;
        height: 32px;
        border-radius: 6px;
        background: var(--dark-surface, #1F1F1F);
        color: var(--text-muted, #808080);
        border: 1px solid var(--dark-border, #2D2D2D);
        cursor: pointer;
        font-size: 16px;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: all 0.2s;
    }

    .epg-nav-btn:hover {
        background: var(--dark-hover, #2A2A2A);
        color: #fff;
        border-color: var(--primary-500, #E50914);
    }

    .epg-date {
        color: #fff;
        font-weight: 500;
        font-size: 14px;
        min-width: 200px;
        text-align: center;
    }

    /* Filter Bar */
    .epg-filter-bar {
        display: flex;
        align-items: center;
        gap: 12px;
        padding: 10px 16px;
        background: var(--dark-bg, #0A0A0A);
        border-bottom: 1px solid var(--dark-border, #2D2D2D);
        flex-shrink: 0;
    }

    .epg-search-wrapper {
        position: relative;
        flex: 1;
        max-width: 400px;
    }

    .epg-search-icon {
        position: absolute;
        left: 12px;
        top: 50%;
        transform: translateY(-50%);
        width: 18px;
        height: 18px;
        color: var(--text-muted, #808080);
        pointer-events: none;
    }

    .epg-search-input {
        width: 100%;
        padding: 8px 36px 8px 40px;
        background: var(--dark-surface, #1F1F1F);
        border: 1px solid var(--dark-border, #2D2D2D);
        border-radius: 8px;
        color: #fff;
        font-size: 14px;
        transition: all 0.2s;
    }

    .epg-search-input:focus {
        outline: none;
        border-color: var(--primary-500, #E50914);
        box-shadow: 0 0 0 3px rgba(229, 9, 20, 0.2);
    }

    .epg-search-input::placeholder {
        color: var(--text-muted, #808080);
    }

    .epg-clear-btn {
        position: absolute;
        right: 8px;
        top: 50%;
        transform: translateY(-50%);
        padding: 4px;
        background: transparent;
        border: none;
        color: var(--text-muted, #808080);
        cursor: pointer;
        border-radius: 4px;
        transition: all 0.2s;
    }

    .epg-clear-btn:hover {
        background: var(--dark-hover, #2A2A2A);
        color: #fff;
    }

    .epg-clear-btn.hidden {
        display: none;
    }

    .epg-country-wrapper {
        flex-shrink: 0;
    }

    .epg-country-wrapper .select {
        min-width: 180px;
        padding: 8px 32px 8px 12px;
        font-size: 14px;
        background: var(--dark-surface, #1F1F1F);
        border: 1px solid var(--dark-border, #2D2D2D);
        border-radius: 8px;
        color: #fff;
    }

    .epg-filter-info {
        color: var(--text-muted, #808080);
        font-size: 13px;
        margin-left: auto;
    }

    .epg-time-range {
        display: flex;
        align-items: center;
        gap: 8px;
        flex-shrink: 0;
    }

    .time-range-label {
        color: var(--text-muted, #808080);
        font-size: 13px;
        white-space: nowrap;
    }

    .time-input {
        padding: 6px 10px;
        background: var(--dark-surface, #1F1F1F);
        border: 1px solid var(--dark-border, #2D2D2D);
        border-radius: 6px;
        color: #fff;
        font-size: 13px;
        width: 100px;
    }

    .time-input:focus {
        outline: none;
        border-color: var(--primary-500, #E50914);
    }

    .time-range-separator {
        color: var(--text-muted, #808080);
    }

    .time-reset-btn {
        padding: 6px 10px;
        font-size: 12px;
    }

    /* Grid Container */
    .epg-grid-container {
        flex: 1;
        display: flex;
        flex-direction: column;
        overflow: hidden;
        min-height: 0;
    }

    /* Timeline Row */
    .epg-timeline-row {
        display: flex;
        flex-shrink: 0;
        background: var(--dark-card, #141414);
        border-bottom: 1px solid var(--dark-border, #2D2D2D);
    }

    .epg-corner {
        width: 180px;
        flex-shrink: 0;
        background: var(--dark-card, #141414);
        border-right: 1px solid var(--dark-border, #2D2D2D);
    }

    .epg-timeline {
        display: flex;
        overflow-x: auto;
        overflow-y: hidden;
        scrollbar-width: none;
    }

    .epg-timeline::-webkit-scrollbar {
        display: none;
    }

    .epg-time-slot {
        width: 240px;
        flex-shrink: 0;
        padding: 8px 12px;
        color: var(--text-muted, #808080);
        font-size: 13px;
        font-weight: 500;
        border-right: 1px solid var(--dark-border, #2D2D2D);
        position: relative;
    }

    .epg-time-slot::after {
        content: '';
        position: absolute;
        right: 50%;
        top: 100%;
        width: 1px;
        height: 8px;
        background: var(--dark-border, #2D2D2D);
    }

    /* Channel Rows */
    .epg-rows-container {
        flex: 1;
        overflow-y: auto;
        overflow-x: hidden;
    }

    .epg-channel-row {
        display: flex;
        height: 52px;
        border-bottom: 1px solid var(--dark-bg, #0A0A0A);
    }

    .epg-channel-row:nth-child(odd) {
        background: var(--dark-card, #141414);
    }

    .epg-channel-row:nth-child(even) {
        background: var(--dark-surface, #1F1F1F);
    }

    .epg-channel-cell {
        width: 180px;
        flex-shrink: 0;
        padding: 8px 10px;
        display: flex;
        align-items: center;
        gap: 8px;
        border-right: 1px solid var(--dark-border, #2D2D2D);
        background: inherit;
    }

    .epg-channel-logo {
        width: 32px;
        height: 32px;
        border-radius: 6px;
        background: var(--dark-surface, #1F1F1F);
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 10px;
        font-weight: 600;
        color: var(--text-muted, #808080);
        flex-shrink: 0;
    }

    .epg-channel-info {
        overflow: hidden;
    }

    .epg-channel-name {
        color: #fff;
        font-size: 13px;
        font-weight: 500;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
    }

    .epg-channel-country {
        color: var(--text-muted, #808080);
        font-size: 11px;
    }

    /* Programs Timeline */
    .epg-programs-timeline {
        flex: 1;
        display: flex;
        position: relative;
        overflow-x: auto;
        overflow-y: hidden;
        scrollbar-width: none;
    }

    .epg-programs-timeline::-webkit-scrollbar {
        display: none;
    }

    .epg-program {
        position: absolute;
        top: 4px;
        bottom: 4px;
        border-radius: 6px;
        padding: 4px 8px;
        cursor: pointer;
        overflow: hidden;
        display: flex;
        flex-direction: column;
        justify-content: center;
        transition: transform 0.15s, z-index 0s;
        border: 1px solid transparent;
    }

    .epg-program:hover {
        transform: scale(1.02);
        z-index: 5;
        border-color: rgba(255,255,255,0.3);
    }

    .epg-program.now {
        background: linear-gradient(135deg, var(--primary-500, #E50914) 0%, #FF1A1A 100%);
        border-color: var(--primary-500, #E50914);
    }

    .epg-program.future {
        background: var(--dark-surface, #1F1F1F);
    }

    .epg-program.past {
        background: var(--dark-bg, #0A0A0A);
        opacity: 0.5;
    }

    .epg-program-title {
        font-size: 12px;
        font-weight: 500;
        color: #fff;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
    }

    .epg-program-time {
        font-size: 10px;
        color: rgba(255,255,255,0.6);
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
    }

    /* Now Indicator */
    .now-indicator {
        position: absolute;
        top: 0;
        bottom: 0;
        width: 2px;
        background: var(--primary-500, #E50914);
        z-index: 20;
        pointer-events: none;
    }

    .now-indicator::before {
        content: '';
        position: absolute;
        top: -4px;
        left: -4px;
        width: 10px;
        height: 10px;
        background: var(--primary-500, #E50914);
        border-radius: 50%;
    }

    /* Recordings Section - Fixed at bottom */
    .epg-recordings {
        position: fixed;
        bottom: 0;
        left: 0;
        right: 0;
        height: 100px;
        padding: 16px;
        background: var(--dark-card, #141414);
        border-top: 1px solid var(--dark-border, #2D2D2D);
        overflow-y: auto;
        z-index: 30;
        box-shadow: 0 -4px 12px rgba(0, 0, 0, 0.5);
    }

    .recordings-list {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
    }

    .recording-item {
        background: var(--dark-surface, #1F1F1F);
        border-radius: 8px;
        padding: 8px 12px;
        display: flex;
        align-items: center;
        gap: 12px;
        min-width: 280px;
        border: 1px solid var(--dark-border, #2D2D2D);
    }

    .recording-info h4 {
        color: #fff;
        font-size: 13px;
        font-weight: 500;
    }

    .recording-info p {
        color: var(--text-muted, #808080);
        font-size: 11px;
    }

    .recording-status {
        font-size: 10px;
        padding: 2px 6px;
        border-radius: 4px;
        font-weight: 500;
    }

    .recording-status.scheduled { background: rgba(59, 130, 246, 0.2); color: #60a5fa; }
    .recording-status.recording { background: rgba(239, 68, 68, 0.2); color: #f87171; animation: pulse 2s infinite; }
    .recording-status.completed { background: rgba(34, 197, 94, 0.2); color: #4ade80; }
    .recording-status.failed { background: rgba(239, 68, 68, 0.2); color: #f87171; }

    .recording-duration {
        font-family: monospace;
        font-size: 14px;
        font-weight: 600;
        color: var(--primary-500, #E50914);
        background: rgba(229, 9, 20, 0.15);
        padding: 4px 8px;
        border-radius: 4px;
        min-width: 60px;
        text-align: center;
    }

    @keyframes pulse {
        0%, 100% { opacity: 1; }
        50% { opacity: 0.7; }
    }

    .btn-danger {
        background: var(--primary-500, #E50914);
        color: white;
    }

    .btn-danger:hover {
        background: #C41018;
    }

    .btn-info {
        background: #0EA5E9;
        color: white;
    }

    .btn-info:hover {
        background: #0284C7;
    }

    /* Empty State */
    .epg-empty {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        height: 100%;
        color: var(--text-muted, #808080);
        text-align: center;
        padding: 40px;
    }

    .epg-empty p {
        margin: 8px 0;
    }

    .epg-empty .btn {
        margin-top: 16px;
    }

    /* Sync scroll handling */
    .sync-scroll {
        scroll-behavior: auto;
    }

    /* Loading Overlay */
    .epg-loading {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(10, 10, 10, 0.95);
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        z-index: 40;
        gap: 16px;
    }

    .epg-loading.hidden {
        display: none;
    }

    .epg-loading p {
        color: var(--text-muted, #808080);
        font-size: 14px;
    }

    .epg-loading-spinner {
        width: 48px;
        height: 48px;
        border: 3px solid var(--dark-surface, #1F1F1F);
        border-top-color: var(--primary-500, #E50914);
        border-radius: 50%;
        animation: spin 1s linear infinite;
    }

    @keyframes spin {
        to { transform: rotate(360deg); }
    }
</style>

<script>
    const SLOT_WIDTH = 240; // pixels per hour (more spacious)
    const CHANNEL_WIDTH = 180; // channel column width (narrower)

    // Default: current time - 30 mins to +3 hours (3.5 hours visible)
    const DEFAULT_HOURS_BEFORE = 0.5; // 30 minutes before current time
    const DEFAULT_HOURS_AFTER = 3;    // 3 hours after current time

    let currentDate = new Date();
    let epgData = [];
    let allChannels = []; // All channels from API
    let channels = []; // Filtered channels for display
    let availableCountries = [];
    let matchingLiveChannels = [];
    let selectedProgram = null;
    let isSyncing = false;
    let searchQuery = '';
    let selectedCountry = '';
    let epgSearchTimeout = null;

    // Time range state
    let timeRangeStart = null; // Custom start time (null = use default)
    let timeRangeEnd = null;   // Custom end time (null = use default)

    document.addEventListener('DOMContentLoaded', () => {
        initTimeRange();
        goToNow();
        loadRecordings();

        // Sync horizontal scroll between timeline and all program rows
        const timeline = document.getElementById('time-header');

        timeline.addEventListener('scroll', () => {
            if (isSyncing) return;
            isSyncing = true;
            syncScroll(timeline.scrollLeft);
            isSyncing = false;
        });

        // Socket events for recording updates
        socket.on('recording:scheduled', () => loadRecordings());
        socket.on('recording:started', () => loadRecordings());
        socket.on('recording:completed', () => loadRecordings());
        socket.on('recording:cancelled', () => loadRecordings());
    });

    function populateCountryDropdown() {
        // Extract unique countries from loaded EPG channels
        const countrySet = new Set();
        for (const ch of allChannels) {
            if (ch.country) countrySet.add(ch.country);
        }
        availableCountries = Array.from(countrySet).sort();

        const select = document.getElementById('epg-country-filter');
        if (availableCountries.length === 0) {
            select.innerHTML = '<option value="">All Channels</option>';
        } else {
            select.innerHTML = '<option value="">All Countries (' + availableCountries.length + ')</option>' +
                availableCountries.map(c => \`<option value="\${c}">\${c}</option>\`).join('');
        }
    }

    function handleSearch(value) {
        // Debounce search
        clearTimeout(epgSearchTimeout);
        epgSearchTimeout = setTimeout(() => {
            searchQuery = value.trim().toLowerCase();
            document.getElementById('clear-search-btn').classList.toggle('hidden', !searchQuery);
            applyFilters();
        }, 300);
    }

    function clearSearch() {
        document.getElementById('epg-search').value = '';
        searchQuery = '';
        document.getElementById('clear-search-btn').classList.add('hidden');
        applyFilters();
    }

    function handleCountryChange(value) {
        selectedCountry = value;
        applyFilters();
    }

    function applyFilters() {
        // Filter channels by country
        let filtered = allChannels;

        if (selectedCountry) {
            filtered = filtered.filter(c => c.country === selectedCountry);
        }

        // Filter by search query (channel name or program title)
        if (searchQuery) {
            const matchingChannelIds = new Set();

            // Check channel names
            for (const ch of filtered) {
                if (ch.title.toLowerCase().includes(searchQuery)) {
                    matchingChannelIds.add(ch.tvg_id);
                }
            }

            // Check program titles
            for (const program of epgData) {
                if (program.title && program.title.toLowerCase().includes(searchQuery)) {
                    matchingChannelIds.add(program.channel_id);
                }
            }

            filtered = filtered.filter(c => matchingChannelIds.has(c.tvg_id));
        }

        channels = filtered;
        renderGrid();
        updateFilterInfo();
    }

    function updateFilterInfo() {
        const info = document.getElementById('epg-filter-info');
        const total = allChannels.length;
        const showing = channels.length;

        if (searchQuery || selectedCountry) {
            info.textContent = \`Showing \${showing} of \${total} channels\`;
        } else {
            info.textContent = \`\${total} channels\`;
        }
    }

    function syncScroll(scrollLeft) {
        const timeline = document.getElementById('time-header');
        const rows = document.querySelectorAll('.epg-programs-timeline');

        timeline.scrollLeft = scrollLeft;
        rows.forEach(row => row.scrollLeft = scrollLeft);
    }

    function showLoading(message = 'Loading TV Guide...') {
        const loading = document.getElementById('epg-loading');
        loading.querySelector('p').textContent = message;
        loading.classList.remove('hidden');
    }

    function hideLoading() {
        document.getElementById('epg-loading').classList.add('hidden');
    }

    function formatTime(date) {
        return date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
    }

    function formatDate(date) {
        return date.toLocaleDateString([], { weekday: 'short', month: 'short', day: 'numeric' });
    }

    function initTimeRange() {
        // Set default time inputs based on current time
        updateTimeInputsToDefault();
    }

    function updateTimeInputsToDefault() {
        const now = new Date();
        const startTime = new Date(now.getTime() - DEFAULT_HOURS_BEFORE * 60 * 60 * 1000);
        const endTime = new Date(now.getTime() + DEFAULT_HOURS_AFTER * 60 * 60 * 1000);

        document.getElementById('time-start').value = formatTimeForInput(startTime);
        document.getElementById('time-end').value = formatTimeForInput(endTime);
    }

    function formatTimeForInput(date) {
        const hours = date.getHours().toString().padStart(2, '0');
        const mins = date.getMinutes().toString().padStart(2, '0');
        return \`\${hours}:\${mins}\`;
    }

    function getTimeRange() {
        // Always calculate based on current time for accuracy
        const now = new Date();
        const startTime = new Date(now.getTime() - DEFAULT_HOURS_BEFORE * 60 * 60 * 1000);
        const endTime = new Date(now.getTime() + DEFAULT_HOURS_AFTER * 60 * 60 * 1000);
        return { startTime, endTime };
    }

    function handleTimeRangeChange() {
        loadEpg();
    }

    function resetTimeRange() {
        updateTimeInputsToDefault();
        goToNow();
    }

    function goToNow() {
        currentDate = new Date();
        currentDate.setMinutes(0, 0, 0);
        updateTimeInputsToDefault();
        loadEpg();
    }

    function scrollTime(hours) {
        currentDate.setHours(currentDate.getHours() + hours);
        loadEpg();
    }

    function generateTimeHeader() {
        const header = document.getElementById('time-header');
        const { startTime, endTime } = getTimeRange();

        // Calculate hours to show
        const hoursToShow = Math.ceil((endTime - startTime) / (60 * 60 * 1000));

        let html = '';
        for (let i = 0; i < hoursToShow; i++) {
            const slotTime = new Date(startTime.getTime() + i * 60 * 60 * 1000);
            html += \`<div class="epg-time-slot">\${formatTime(slotTime)}</div>\`;
        }

        header.innerHTML = html;
        document.getElementById('current-date').textContent = formatDate(startTime);
    }

    async function loadEpg() {
        showLoading('Loading Live TV channels...');
        generateTimeHeader();

        const { startTime, endTime } = getTimeRange();
        const start = startTime.toISOString();
        const end = endTime.toISOString();

        try {
            // Fetch Live TV channels that have tvg_id set (EPG mapping)
            const liveResp = await fetch('/api/epg/live-channels');
            const channelsWithEpg = await liveResp.json();

            if (channelsWithEpg.length === 0) {
                hideLoading();
                document.getElementById('epg-rows-container').innerHTML = \`
                    <div class="epg-empty">
                        <svg class="w-16 h-16 mb-4 text-dark-600" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="1" d="M9.75 17L9 20l-1 1h8l-1-1-.75-3M3 13h18M5 17h14a2 2 0 002-2V5a2 2 0 00-2-2H5a2 2 0 00-2 2v10a2 2 0 002 2z" />
                        </svg>
                        <p class="text-lg text-dark-400">No Live TV channels with EPG</p>
                        <p class="text-sm text-dark-500">Sync EPG data in Settings to map channels</p>
                        <a href="/settings" class="btn btn-primary">Open Settings</a>
                    </div>
                \`;
                updateFilterInfo();
                return;
            }

            // Store Live TV channels with EPG mapping
            allChannels = channelsWithEpg.map(ch => ({
                id: ch.id,
                tvg_id: ch.tvg_id,
                title: ch.title,
                country: ch.tvg_id?.match(/\\.([a-z]{2})$/i)?.[1]?.toUpperCase() || null,
                poster: ch.poster,
                stream_url: ch.stream_url,
                category: ch.category
            }));

            // Populate country dropdown from actual channel data
            populateCountryDropdown();

            showLoading(\`Loading program guide for \${allChannels.length} channels...\`);

            const channelIds = allChannels.map(c => c.tvg_id);
            const epgResp = await fetch('/api/epg/guide', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ start, end, channels: channelIds })
            });
            epgData = await epgResp.json();

            showLoading('Rendering guide...');

            // Apply current filters
            applyFilters();

            hideLoading();

            // Scroll to current time after a short delay
            setTimeout(() => {
                scrollToNow();
            }, 100);
        } catch (err) {
            console.error('Failed to load EPG:', err);
            hideLoading();
            document.getElementById('epg-rows-container').innerHTML = \`
                <div class="epg-empty">
                    <p class="text-red-400">Failed to load EPG data</p>
                    <p class="text-sm text-dark-500">\${err.message}</p>
                </div>
            \`;
        }
    }

    function getChannelInitials(name) {
        return name.split(/\\s+/).map(w => w[0]).join('').substring(0, 3).toUpperCase();
    }

    function renderGrid() {
        const container = document.getElementById('epg-rows-container');
        const { startTime: rangeStart, endTime: rangeEnd } = getTimeRange();
        const startTime = rangeStart.getTime();
        const endTime = rangeEnd.getTime();
        const hoursVisible = (rangeEnd - rangeStart) / (60 * 60 * 1000);
        const totalWidth = hoursVisible * SLOT_WIDTH;
        const now = Date.now();

        // Build program lookup with case-insensitive keys
        const programsByChannel = {};
        for (const program of epgData) {
            const key = program.channel_id?.toLowerCase();
            if (!key) continue;
            if (!programsByChannel[key]) {
                programsByChannel[key] = [];
            }
            programsByChannel[key].push(program);
        }

        let html = '';

        for (const channel of channels) {
            const programs = programsByChannel[channel.tvg_id?.toLowerCase()] || [];
            programs.sort((a, b) => new Date(a.start_time) - new Date(b.start_time));

            html += \`
                <div class="epg-channel-row">
                    <div class="epg-channel-cell">
                        <div class="epg-channel-logo">\${getChannelInitials(channel.title)}</div>
                        <div class="epg-channel-info">
                            <div class="epg-channel-name" title="\${channel.title}">\${channel.title}</div>
                            <div class="epg-channel-country">\${channel.country || ''}</div>
                        </div>
                    </div>
                    <div class="epg-programs-timeline sync-scroll" style="width: calc(100% - \${CHANNEL_WIDTH}px);" onscroll="handleRowScroll(event)">
                        <div style="width: \${totalWidth}px; height: 100%; position: relative;">
            \`;

            for (const program of programs) {
                const programStart = new Date(program.start_time).getTime();
                const programEnd = program.end_time ? new Date(program.end_time).getTime() : programStart + 60 * 60 * 1000;

                // Skip programs that end before the visible range starts
                if (programEnd < startTime) continue;
                // Skip programs that start after the visible range ends
                if (programStart > endTime) continue;

                const leftOffset = Math.max(0, (programStart - startTime) / (60 * 60 * 1000)) * SLOT_WIDTH;
                const visibleStart = Math.max(programStart, startTime);
                const visibleEnd = Math.min(programEnd, endTime);
                const duration = (visibleEnd - visibleStart) / (60 * 60 * 1000);
                const width = Math.max(60, duration * SLOT_WIDTH);

                const isNow = programStart <= now && programEnd > now;
                const isPast = programEnd <= now;
                const statusClass = isNow ? 'now' : (isPast ? 'past' : 'future');

                html += \`
                    <div class="epg-program \${statusClass}"
                         style="left: \${leftOffset}px; width: \${width - 4}px;"
                         onclick="showProgram(\${program.id}, '\${channel.tvg_id}')"
                         title="\${program.title}">
                        <div class="epg-program-title">\${program.title}</div>
                        <div class="epg-program-time">\${formatTime(new Date(program.start_time))}\${program.end_time ? ' - ' + formatTime(new Date(program.end_time)) : ''}</div>
                    </div>
                \`;
            }

            // Add now indicator for this row
            const nowOffset = ((now - startTime) / (60 * 60 * 1000)) * SLOT_WIDTH;
            if (nowOffset >= 0 && nowOffset <= totalWidth) {
                html += \`<div class="now-indicator" style="left: \${nowOffset}px;"></div>\`;
            }

            html += \`
                        </div>
                    </div>
                </div>
            \`;
        }

        container.innerHTML = html || \`
            <div class="epg-empty">
                <p class="text-dark-400">No programs found for this time</p>
            </div>
        \`;
    }

    function handleRowScroll(event) {
        if (isSyncing) return;
        isSyncing = true;
        syncScroll(event.target.scrollLeft);
        isSyncing = false;
    }

    function scrollToNow() {
        const now = Date.now();
        const startTime = currentDate.getTime();
        const nowOffset = ((now - startTime) / (60 * 60 * 1000)) * SLOT_WIDTH;

        // Center the view on current time (subtract half viewport width)
        const viewportWidth = document.querySelector('.epg-programs-timeline')?.offsetWidth || 800;
        const targetScroll = Math.max(0, nowOffset - viewportWidth / 3);

        syncScroll(targetScroll);
    }

    async function showProgram(programId, channelTvgId) {
        try {
            const resp = await fetch(\`/api/epg/program/\${programId}\`);
            selectedProgram = await resp.json();
            selectedProgram.channelTvgId = channelTvgId;

            const channel = channels.find(c => c.tvg_id === channelTvgId);

            document.getElementById('modal-program-title').textContent = selectedProgram.title || 'Unknown';
            document.getElementById('modal-program-channel').textContent = channel?.title || selectedProgram.channel_id;
            document.getElementById('modal-program-time').textContent = \`\${formatTime(new Date(selectedProgram.start_time))} - \${selectedProgram.end_time ? formatTime(new Date(selectedProgram.end_time)) : 'End unknown'}\`;
            document.getElementById('modal-program-category').textContent = selectedProgram.category || '';
            document.getElementById('modal-program-description').textContent = selectedProgram.description || 'No description available';

            const programEnd = selectedProgram.end_time ? new Date(selectedProgram.end_time) : new Date(selectedProgram.start_time);
            const canRecord = programEnd > new Date();
            document.getElementById('record-btn').style.display = canRecord ? 'flex' : 'none';

            if (canRecord) {
                await loadMatchingChannels(channelTvgId, channel?.title, channel?.country);
            } else {
                document.getElementById('source-selection-container').style.display = 'none';
            }

            document.getElementById('program-modal').classList.remove('hidden');
            document.getElementById('program-modal').classList.add('flex');
        } catch (err) {
            console.error('Failed to load program:', err);
            if (window.showToast) showToast('Failed to load program details', 'error');
        }
    }

    // Map country codes to common IPTV channel prefixes
    const COUNTRY_TO_PREFIX = {
        'DE': ['DE', 'GER', 'GERMANY'],
        'AT': ['AT', 'AUT', 'AUSTRIA'],
        'CH': ['CH', 'SUI', 'SWISS'],
        'UK': ['UK', 'GB', 'GBR'],
        'US': ['US', 'USA'],
        'FR': ['FR', 'FRA', 'FRANCE'],
        'ES': ['ES', 'ESP', 'SPAIN'],
        'IT': ['IT', 'ITA', 'ITALY'],
        'NL': ['NL', 'NED'],
        'BE': ['BE', 'BEL'],
        'PL': ['PL', 'POL'],
        'PT': ['PT', 'POR'],
        'TR': ['TR', 'TUR'],
        'RU': ['RU', 'RUS'],
        'CA': ['CA', 'CAN'],
        'AU': ['AU', 'AUS']
    };

    async function loadMatchingChannels(tvgId, channelTitle, epgCountry) {
        try {
            const searchTerm = channelTitle || tvgId.replace(/\\.[a-z]{2}$/i, '');
            const resp = await fetch(\`/api/media?type=live&search=\${encodeURIComponent(searchTerm)}&limit=50\`);
            const data = await resp.json();
            let allChannels = data.items || [];

            // Get allowed country prefixes for this EPG channel
            const allowedPrefixes = epgCountry ? (COUNTRY_TO_PREFIX[epgCountry] || []) : [];

            // Filter channels by country prefix if we have a country
            if (allowedPrefixes.length > 0) {
                matchingLiveChannels = allChannels.filter(ch => {
                    // Check if channel title starts with any of the allowed country prefixes
                    const titleUpper = (ch.title || '').toUpperCase();
                    // Match patterns like "DE - " or "DE:" or just "DE " at start
                    for (const prefix of allowedPrefixes) {
                        if (titleUpper.startsWith(prefix + ' - ') ||
                            titleUpper.startsWith(prefix + ': ') ||
                            titleUpper.startsWith(prefix + ' ') ||
                            titleUpper.startsWith(prefix + '|')) {
                            return true;
                        }
                    }
                    // Also include channels without any recognizable country prefix
                    // (they might still be valid matches)
                    const hasAnyCountryPrefix = Object.values(COUNTRY_TO_PREFIX).flat().some(p => {
                        return titleUpper.startsWith(p + ' - ') ||
                               titleUpper.startsWith(p + ': ') ||
                               titleUpper.startsWith(p + ' ') ||
                               titleUpper.startsWith(p + '|');
                    });
                    return !hasAnyCountryPrefix;
                });
            } else {
                // No country filter, use all results
                matchingLiveChannels = allChannels;
            }

            const select = document.getElementById('source-select');
            const noSourceMsg = document.getElementById('no-source-msg');
            const container = document.getElementById('source-selection-container');

            select.innerHTML = '<option value="">-- Select a source --</option>';

            if (matchingLiveChannels.length > 0) {
                for (const ch of matchingLiveChannels) {
                    const sourceName = ch.source_name || 'Unknown source';
                    select.innerHTML += \`<option value="\${ch.id}">\${ch.title} (\${sourceName})</option>\`;
                }
                noSourceMsg.style.display = 'none';
                select.style.display = 'block';
                document.getElementById('record-btn').disabled = false;
                document.getElementById('play-vlc-btn').style.display = 'flex';
                document.getElementById('play-vlc-ext-btn').style.display = 'flex';
                document.getElementById('play-browser-btn').style.display = 'flex';
            } else {
                noSourceMsg.style.display = 'block';
                select.style.display = 'none';
                document.getElementById('record-btn').disabled = true;
                document.getElementById('play-vlc-btn').style.display = 'none';
                document.getElementById('play-vlc-ext-btn').style.display = 'none';
                document.getElementById('play-browser-btn').style.display = 'none';
            }

            container.style.display = 'block';
        } catch (err) {
            console.error('Failed to load matching channels:', err);
            document.getElementById('source-selection-container').style.display = 'none';
        }
    }

    function closeModal() {
        document.getElementById('program-modal').classList.add('hidden');
        document.getElementById('program-modal').classList.remove('flex');
        selectedProgram = null;
        matchingLiveChannels = [];
    }

    async function playInVLC() {
        const selectedSource = document.getElementById('source-select').value;

        // Find the channel to play - either selected or first available
        let channelToPlay = null;
        if (selectedSource) {
            channelToPlay = matchingLiveChannels.find(ch => ch.id === parseInt(selectedSource));
        } else if (matchingLiveChannels.length > 0) {
            channelToPlay = matchingLiveChannels[0];
        }

        if (!channelToPlay || !channelToPlay.stream_url) {
            if (window.showToast) showToast('No stream URL available', 'error');
            return;
        }

        const m3uUrl = '/api/play.m3u?url=' + encodeURIComponent(channelToPlay.stream_url);
        window.location.href = m3uUrl;
        if (window.showToast) showToast('Downloading M3U for VLC...', 'success');
    }

    function playInBrowser() {
        const selectedSource = document.getElementById('source-select').value;

        // Find the channel to play - either selected or first available
        let channelToPlay = null;
        if (selectedSource) {
            channelToPlay = matchingLiveChannels.find(ch => ch.id === parseInt(selectedSource));
        } else if (matchingLiveChannels.length > 0) {
            channelToPlay = matchingLiveChannels[0];
        }

        if (!channelToPlay || !channelToPlay.stream_url) {
            if (window.showToast) showToast('No stream URL available', 'error');
            return;
        }

        // Close the program modal first
        closeModal();

        const browserUrl = '/player?url=' + encodeURIComponent(channelToPlay.stream_url);
        window.open(browserUrl, '_blank', 'noopener');
        if (window.showToast) showToast('Opening in browser...', 'success');
    }

    function playInVlcExtension() {
        const selectedSource = document.getElementById('source-select').value;

        let channelToPlay = null;
        if (selectedSource) {
            channelToPlay = matchingLiveChannels.find(ch => ch.id === parseInt(selectedSource));
        } else if (matchingLiveChannels.length > 0) {
            channelToPlay = matchingLiveChannels[0];
        }

        if (!channelToPlay || !channelToPlay.stream_url) {
            if (window.showToast) showToast('No stream URL available', 'error');
            return;
        }

        window.open(channelToPlay.stream_url, '_blank', 'noopener');
        if (window.showToast) showToast('Open the VLC extension to play this stream', 'success');
    }

    async function scheduleRecording() {
        if (!selectedProgram) return;

        const selectedSource = document.getElementById('source-select').value;
        if (!selectedSource) {
            if (window.showToast) showToast('Please select a source to record from', 'error');
            return;
        }

        try {
            const resp = await fetch('/api/recordings', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    mediaId: parseInt(selectedSource),
                    channelTvgId: selectedProgram.channelTvgId,
                    title: selectedProgram.title,
                    startTime: selectedProgram.start_time,
                    endTime: selectedProgram.end_time,
                    epgProgramId: selectedProgram.id
                })
            });

            const result = await resp.json();
            if (resp.ok) {
                if (window.showToast) showToast('Recording scheduled!', 'success');
                closeModal();
                loadRecordings();
            } else {
                throw new Error(result.error);
            }
        } catch (err) {
            console.error('Failed to schedule recording:', err);
            if (window.showToast) showToast('Failed to schedule: ' + err.message, 'error');
        }
    }

    async function loadRecordings() {
        try {
            const resp = await fetch('/api/recordings?upcoming=true');
            const recordings = await resp.json();

            const container = document.getElementById('recordings-list');
            if (recordings.length === 0) {
                container.innerHTML = '<p class="text-dark-400 text-sm">No recordings scheduled</p>';
                return;
            }

            container.innerHTML = recordings.map(rec => {
                const endTime = new Date(rec.end_time);
                const endTimeStr = endTime.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });

                // Calculate recording duration if recording
                let durationInfo = '';
                if (rec.status === 'recording') {
                    const actualStart = rec.actual_start_time ? new Date(rec.actual_start_time) : new Date();
                    const elapsed = Math.floor((Date.now() - actualStart.getTime()) / 1000);
                    const mins = Math.floor(elapsed / 60);
                    const secs = elapsed % 60;
                    durationInfo = \`<span class="recording-duration" data-start="\${actualStart.toISOString()}">\${mins}:\${secs.toString().padStart(2, '0')}</span>\`;
                }

                return \`
                    <div class="recording-item" data-recording-id="\${rec.id}">
                        <div class="recording-info">
                            <h4>\${rec.title}</h4>
                            <p>\${rec.channel_name || 'Channel'} &bull; ends \${endTimeStr}</p>
                        </div>
                        \${durationInfo}
                        <span class="recording-status \${rec.status}">\${rec.status}</span>
                        \${rec.status === 'scheduled' ? \`<button onclick="cancelRecording(\${rec.id})" class="btn btn-secondary btn-sm">Cancel</button>\` : ''}
                        \${rec.status === 'recording' ? \`<button onclick="stopRecordingNow(\${rec.id})" class="btn btn-danger btn-sm">Stop</button>\` : ''}
                    </div>
                \`;
            }).join('');
        } catch (err) {
            console.error('Failed to load recordings:', err);
        }
    }

    async function cancelRecording(id) {
        if (!confirm('Cancel this recording?')) return;
        try {
            await fetch(\`/api/recordings/\${id}/cancel\`, { method: 'POST' });
            loadRecordings();
            if (window.showToast) showToast('Recording cancelled', 'info');
        } catch (err) {
            console.error('Failed to cancel recording:', err);
        }
    }

    async function stopRecordingNow(id) {
        if (!confirm('Stop this recording now?')) return;
        try {
            await fetch(\`/api/recordings/\${id}/stop\`, { method: 'POST' });
            loadRecordings();
            if (window.showToast) showToast('Recording stopped', 'info');
        } catch (err) {
            console.error('Failed to stop recording:', err);
            if (window.showToast) showToast('Failed to stop recording', 'error');
        }
    }

    // Update recording durations every second
    function updateRecordingDurations() {
        const durationElements = document.querySelectorAll('.recording-duration');
        durationElements.forEach(el => {
            const startTime = new Date(el.dataset.start);
            const elapsed = Math.floor((Date.now() - startTime.getTime()) / 1000);
            const hours = Math.floor(elapsed / 3600);
            const mins = Math.floor((elapsed % 3600) / 60);
            const secs = elapsed % 60;

            if (hours > 0) {
                el.textContent = \`\${hours}:\${mins.toString().padStart(2, '0')}:\${secs.toString().padStart(2, '0')}\`;
            } else {
                el.textContent = \`\${mins}:\${secs.toString().padStart(2, '0')}\`;
            }
        });
    }

    // Update durations every second
    setInterval(updateRecordingDurations, 1000);

    // Refresh recordings every 30 seconds
    setInterval(loadRecordings, 30000);

    // Update now indicators every minute
    setInterval(() => {
        renderGrid();
    }, 60000);
</script>
` }) %>
