<%- include('layouts/main', { title: 'Settings', body: `
<div class="p-8">
    <div class="mb-8">
        <h1 class="text-3xl font-bold text-white">Settings</h1>
        <p class="text-dark-400 mt-1">Configure RecoStream</p>
    </div>

    <div class="grid grid-cols-1 lg:grid-cols-2 gap-8">
        <!-- IPTV Sources -->
        <div class="card">
            <div class="p-4 border-b border-dark-700 flex items-center justify-between">
                <h2 class="text-lg font-semibold text-white">IPTV Sources</h2>
                <button onclick="showAddSource()" class="btn btn-primary btn-sm">Add Source</button>
            </div>
            <div id="sources-list" class="divide-y divide-dark-700">
                <p class="text-dark-400 text-center py-8">No sources configured</p>
            </div>
        </div>

        <!-- Folder Settings -->
        <div class="card">
            <div class="p-4 border-b border-dark-700">
                <h2 class="text-lg font-semibold text-white">Folders</h2>
            </div>
            <div class="p-4 space-y-4">
                <div>
                    <label class="block text-sm text-dark-400 mb-1">Temp Download Folder</label>
                    <input type="text" id="setting-tempPath" class="input" placeholder="/path/to/temp" />
                </div>
                <div class="pt-3 border-t border-dark-700">
                    <label class="block text-sm text-white font-medium mb-3">Download Destinations</label>
                    <div class="space-y-3">
                        <div>
                            <label class="block text-xs text-dark-400 mb-1">Movies Folder</label>
                            <input type="text" id="setting-movieDownloadPath" class="input" placeholder="smb://server/Movies or /path/to/movies" />
                        </div>
                        <div>
                            <label class="block text-xs text-dark-400 mb-1">Series Folder</label>
                            <input type="text" id="setting-seriesDownloadPath" class="input" placeholder="smb://server/Shows or /path/to/series" />
                        </div>
                        <div>
                            <label class="block text-xs text-dark-400 mb-1">Live TV Recordings Folder</label>
                            <input type="text" id="setting-recordingsPath" class="input" placeholder="smb://server/TV or /path/to/recordings" />
                        </div>
                    </div>
                    <p class="text-xs text-dark-500 mt-2">Supports SMB paths (smb://server/share) and local paths</p>
                </div>
            </div>
        </div>

        <!-- TMDB Settings -->
        <div class="card">
            <div class="p-4 border-b border-dark-700">
                <h2 class="text-lg font-semibold text-white">TMDB</h2>
            </div>
            <div class="p-4 space-y-4">
                <div>
                    <label class="block text-sm text-dark-400 mb-1">API Key</label>
                    <input type="password" id="setting-tmdbApiKey" class="input" placeholder="Your TMDB API key" />
                    <p class="text-xs text-dark-500 mt-1">Get your key at <a href="https://www.themoviedb.org/settings/api" target="_blank" class="text-primary-400 hover:underline">themoviedb.org</a></p>
                </div>
                <div class="pt-2 border-t border-dark-700">
                    <div class="flex items-center justify-between mb-3">
                        <div>
                            <p class="text-sm text-white">Enrich Posters from TMDB</p>
                            <p class="text-xs text-dark-400" id="enrich-stats">Loading stats...</p>
                        </div>
                        <div class="flex gap-2">
                            <button id="enrich-btn" onclick="startEnrichment()" class="btn btn-secondary btn-sm">Start</button>
                            <button id="enrich-stop-btn" onclick="stopEnrichment()" class="btn btn-danger btn-sm hidden">Stop</button>
                        </div>
                    </div>
                    <!-- Enrichment Progress (Parallel Workers) -->
                    <div id="enrich-progress" class="hidden space-y-3">
                        <div class="flex items-center justify-between">
                            <div class="flex items-center gap-2">
                                <div class="animate-spin w-4 h-4 border-2 border-primary-500 border-t-transparent rounded-full"></div>
                                <span class="text-sm text-white font-medium" id="enrich-status">Starting...</span>
                            </div>
                            <span class="text-xs text-dark-400" id="enrich-rate"></span>
                        </div>
                        <div class="w-full bg-dark-700 rounded-full h-2">
                            <div class="bg-primary-500 h-2 rounded-full transition-all duration-300" id="enrich-bar" style="width: 0%"></div>
                        </div>
                        <div class="grid grid-cols-4 gap-2 text-xs">
                            <div class="text-center p-2 bg-dark-800 rounded">
                                <div class="text-white font-medium" id="enrich-pending">0</div>
                                <div class="text-dark-400">Pending</div>
                            </div>
                            <div class="text-center p-2 bg-dark-800 rounded">
                                <div class="text-primary-400 font-medium" id="enrich-processing">0</div>
                                <div class="text-dark-400">Processing</div>
                            </div>
                            <div class="text-center p-2 bg-dark-800 rounded">
                                <div class="text-green-400 font-medium" id="enrich-completed">0</div>
                                <div class="text-dark-400">Completed</div>
                            </div>
                            <div class="text-center p-2 bg-dark-800 rounded">
                                <div class="text-red-400 font-medium" id="enrich-failed">0</div>
                                <div class="text-dark-400">Failed</div>
                            </div>
                        </div>
                        <div class="flex gap-1" id="enrich-workers">
                            <!-- Worker indicators will be added here -->
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Plex Settings -->
        <div class="card">
            <div class="p-4 border-b border-dark-700">
                <h2 class="text-lg font-semibold text-white">Plex</h2>
            </div>
            <div class="p-4 space-y-4">
                <div>
                    <label class="block text-sm text-dark-400 mb-1">Server URL</label>
                    <input type="text" id="setting-plexUrl" class="input" placeholder="http://192.168.1.100:32400" />
                </div>
                <div>
                    <label class="block text-sm text-dark-400 mb-1">Token</label>
                    <input type="password" id="setting-plexToken" class="input" placeholder="Your Plex token" />
                </div>
                <div class="grid grid-cols-2 gap-4">
                    <div>
                        <label class="block text-sm text-dark-400 mb-1">Movie Library ID</label>
                        <input type="text" id="setting-plexMovieLibraryId" class="input" placeholder="1" />
                    </div>
                    <div>
                        <label class="block text-sm text-dark-400 mb-1">TV Library ID</label>
                        <input type="text" id="setting-plexTvLibraryId" class="input" placeholder="2" />
                    </div>
                </div>
                <button onclick="testPlex()" class="btn btn-secondary w-full">Test Connection</button>
            </div>
        </div>

        <!-- HDHomeRun Emulator Settings -->
        <div class="card">
            <div class="p-4 border-b border-dark-700 flex items-center justify-between">
                <div>
                    <h2 class="text-lg font-semibold text-white">HDHomeRun Emulator</h2>
                    <p class="text-xs text-dark-400">Makes RecoStream appear as an HDHomeRun tuner for Plex Live TV</p>
                </div>
                <label class="relative inline-flex items-center cursor-pointer">
                    <input type="checkbox" id="setting-hdhrEnabled" class="sr-only peer" onchange="toggleHdhr(this.checked)">
                    <div class="w-11 h-6 bg-dark-600 peer-focus:outline-none rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-primary-500"></div>
                </label>
            </div>
            <div class="p-4 space-y-4" id="hdhr-settings">
                <!-- Status -->
                <div class="bg-dark-700 rounded-lg p-3">
                    <div class="flex items-center justify-between">
                        <div>
                            <p class="text-sm text-dark-400 mb-1">Status</p>
                            <p class="text-white font-medium" id="hdhr-status">Checking...</p>
                        </div>
                        <div id="hdhr-status-indicator" class="w-3 h-3 rounded-full bg-dark-500"></div>
                    </div>
                </div>

                <!-- Device Settings -->
                <div class="grid grid-cols-2 gap-4">
                    <div>
                        <label class="block text-sm text-dark-400 mb-1">Device Name</label>
                        <input type="text" id="setting-hdhrFriendlyName" class="input" placeholder="RecoStream HDHR" />
                    </div>
                    <div>
                        <label class="block text-sm text-dark-400 mb-1">Tuner Count</label>
                        <input type="number" id="setting-hdhrTunerCount" class="input" min="1" max="8" value="2" />
                    </div>
                </div>

                <div>
                    <label class="block text-sm text-dark-400 mb-1">Base URL (leave blank to auto-detect)</label>
                    <input type="text" id="setting-hdhrBaseUrl" class="input" placeholder="http://192.168.1.XXX:5004" />
                    <p class="text-xs text-dark-500 mt-1">Override if RecoStream is behind NAT or in Docker</p>
                </div>

                <div>
                    <label class="block text-sm text-dark-400 mb-1">IPTV Source</label>
                    <select id="setting-hdhrSourceId" class="input">
                        <option value="">All sources (no filter)</option>
                    </select>
                    <p class="text-xs text-dark-500 mt-1">Filter channels and EPG to a specific source</p>
                </div>

                <!-- Channel Count -->
                <div class="bg-dark-700 rounded-lg p-3">
                    <div class="flex items-center justify-between">
                        <div>
                            <p class="text-sm text-dark-400">Channels in Lineup</p>
                            <p class="text-white font-medium" id="hdhr-channel-count">0 channels</p>
                        </div>
                        <button onclick="openHdhrChannels()" class="btn btn-secondary btn-sm">Manage Channels</button>
                    </div>
                </div>

                <!-- Plex Setup Instructions -->
                <div class="bg-primary-500/10 rounded-lg p-3 border border-primary-500/20">
                    <p class="text-sm text-primary-400 font-medium mb-2">Plex Setup Instructions</p>
                    <ol class="text-xs text-dark-300 space-y-1 list-decimal list-inside">
                        <li>Enable HDHomeRun emulator above</li>
                        <li>Add channels using "Manage Channels"</li>
                        <li>In Plex: Settings > Live TV & DVR > Set Up Plex DVR</li>
                        <li>Plex should auto-discover "RecoStream HDHR"</li>
                        <li>Add the EPG URL below for guide data</li>
                    </ol>
                    <div class="mt-3 pt-2 border-t border-primary-500/20 space-y-2">
                        <div>
                            <p class="text-xs text-dark-400">EPG URL (for Plex guide data):</p>
                            <code class="text-xs text-primary-400 break-all" id="hdhr-epg-url">Loading...</code>
                        </div>
                        <div>
                            <p class="text-xs text-dark-400">Lineup URL (auto-discovered):</p>
                            <code class="text-xs text-primary-400 break-all" id="hdhr-lineup-url">Loading...</code>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- HDHR Channel Selection Modal -->
        <div id="hdhr-channels-modal" class="modal-overlay hidden">
            <div class="modal-content max-w-4xl">
                <div class="p-4 border-b border-dark-700 flex items-center justify-between">
                    <h3 class="text-lg font-semibold text-white">HDHomeRun Channel Lineup</h3>
                    <button onclick="closeHdhrChannels()" class="text-dark-400 hover:text-white">
                        <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/>
                        </svg>
                    </button>
                </div>
                <div class="p-4 overflow-y-auto max-h-[calc(90vh-140px)]">
                    <!-- Quick Actions -->
                    <div class="flex gap-2 mb-4">
                        <select id="hdhr-category-select" class="input flex-1">
                            <option value="">Select a category to add...</option>
                        </select>
                        <button onclick="addHdhrCategory()" class="btn btn-primary">Add Category</button>
                        <button onclick="clearHdhrChannels()" class="btn btn-secondary">Clear All</button>
                    </div>

                    <!-- Current Lineup -->
                    <div class="mb-4">
                        <h4 class="text-sm font-medium text-white mb-2">Current Lineup (<span id="hdhr-lineup-count">0</span> channels)</h4>
                        <div id="hdhr-lineup" class="space-y-1 max-h-96 overflow-y-auto">
                            <p class="text-sm text-dark-400">No channels in lineup</p>
                        </div>
                    </div>
                </div>
                <div class="p-4 border-t border-dark-700 flex justify-end gap-2">
                    <button onclick="rebuildHdhrLineup()" class="btn btn-secondary">Renumber Channels</button>
                    <button onclick="closeHdhrChannels()" class="btn btn-primary">Done</button>
                </div>
            </div>
        </div>

        <!-- Overseerr Settings -->
        <div class="card">
            <div class="p-4 border-b border-dark-700">
                <h2 class="text-lg font-semibold text-white">Overseerr</h2>
            </div>
            <div class="p-4 space-y-4">
                <div>
                    <label class="block text-sm text-dark-400 mb-1">URL</label>
                    <input type="text" id="setting-overseerrUrl" class="input" placeholder="http://192.168.1.100:5055" />
                </div>
                <div>
                    <label class="block text-sm text-dark-400 mb-1">API Key</label>
                    <input type="password" id="setting-overseerrApiKey" class="input" placeholder="Your Overseerr API key" />
                </div>
                <div class="bg-dark-700 rounded-lg p-3">
                    <p class="text-sm text-dark-400 mb-1">Webhook URL:</p>
                    <code class="text-xs text-primary-400" id="webhook-url">Loading...</code>
                </div>
                <div class="pt-2 border-t border-dark-700">
                    <div class="flex items-center justify-between mb-3">
                        <div>
                            <p class="text-sm text-white">Enrich via Overseerr</p>
                            <p class="text-xs text-dark-400">Fetch posters & metadata using Overseerr API</p>
                        </div>
                        <button id="overseerr-enrich-btn" onclick="startOverseerrEnrichment()" class="btn btn-secondary btn-sm">Fetch Metadata</button>
                    </div>
                    <!-- Overseerr Enrichment Progress -->
                    <div id="overseerr-enrich-progress" class="hidden">
                        <div class="flex items-center gap-2 mb-2">
                            <div class="animate-spin w-4 h-4 border-2 border-primary-500 border-t-transparent rounded-full"></div>
                            <span class="text-sm text-dark-300" id="overseerr-enrich-status">Starting...</span>
                        </div>
                        <div class="w-full bg-dark-700 rounded-full h-2">
                            <div class="bg-primary-500 h-2 rounded-full transition-all duration-300" id="overseerr-enrich-bar" style="width: 0%"></div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Webhooks -->
        <div class="card">
            <div class="p-4 border-b border-dark-700">
                <h2 class="text-lg font-semibold text-white">Webhooks</h2>
            </div>
            <div class="p-4 space-y-4">
                <div>
                    <label class="block text-sm text-dark-400 mb-1">Webhook URL</label>
                    <input type="text" id="setting-webhookUrl" class="input" placeholder="https://your-server/webhook (comma-separated supported)" />
                    <p class="text-xs text-dark-500 mt-1">Sent on download complete and recording finished.</p>
                </div>
            </div>
        </div>

        <!-- Telegram Notifications -->
        <div class="card">
            <div class="p-4 border-b border-dark-700">
                <h2 class="text-lg font-semibold text-white">Telegram Notifications</h2>
            </div>
            <div class="p-4 space-y-4">
                <div class="flex items-center justify-between">
                    <div>
                        <p class="text-sm text-white">Enable Telegram Notifications</p>
                        <p class="text-xs text-dark-400">Send download and recording updates to Telegram.</p>
                    </div>
                    <label class="relative inline-flex items-center cursor-pointer">
                        <input type="checkbox" id="setting-telegramEnabled" class="sr-only peer" />
                        <div class="w-11 h-6 bg-dark-600 peer-focus:outline-none rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-primary-500"></div>
                    </label>
                </div>
                <div>
                    <label class="block text-sm text-dark-400 mb-1">Bot API Token</label>
                    <input type="password" id="setting-telegramBotToken" class="input" placeholder="123456:ABCDEF..." />
                </div>
                <div>
                    <label class="block text-sm text-dark-400 mb-1">Chat ID</label>
                    <input type="text" id="setting-telegramChatId" class="input" placeholder="-1001234567890" />
                </div>
            </div>
        </div>

        <!-- Download Settings -->
        <div class="card">
            <div class="p-4 border-b border-dark-700">
                <h2 class="text-lg font-semibold text-white">Download Settings</h2>
            </div>
            <div class="p-4 space-y-4">
                <div>
                    <label class="block text-sm text-dark-400 mb-1">Max Concurrent Downloads</label>
                    <input type="number" id="setting-maxConcurrentDownloads" class="input" min="1" max="5" value="2" />
                </div>
                <div>
                    <label class="block text-sm text-dark-400 mb-1">Retry Attempts</label>
                    <input type="number" id="setting-downloadRetries" class="input" min="0" max="10" value="3" />
                </div>
                <div class="grid grid-cols-2 gap-4">
                    <div>
                        <label class="block text-sm text-dark-400 mb-1">Min Delay (ms)</label>
                        <input type="number" id="setting-downloadDelayMin" class="input" min="0" value="1000" />
                    </div>
                    <div>
                        <label class="block text-sm text-dark-400 mb-1">Max Delay (ms)</label>
                        <input type="number" id="setting-downloadDelayMax" class="input" min="0" value="5000" />
                    </div>
                </div>
            </div>
        </div>

        <!-- Video Transcoding Settings -->
        <div class="card">
            <div class="p-4 border-b border-dark-700">
                <h2 class="text-lg font-semibold text-white">Video Transcoding</h2>
            </div>
            <div class="p-4 space-y-4">
                <div class="flex items-center justify-between">
                    <div>
                        <p class="text-sm text-white">Enable File Transcoding</p>
                        <p class="text-xs text-dark-400">Convert downloads to MP4 for Plex compatibility</p>
                    </div>
                    <label class="relative inline-flex items-center cursor-pointer">
                        <input type="checkbox" id="setting-transcodeFilesEnabled" class="sr-only peer" />
                        <div class="w-11 h-6 bg-dark-600 peer-focus:outline-none rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-primary-500"></div>
                    </label>
                </div>

                <div class="flex items-center justify-between">
                    <div>
                        <p class="text-sm text-white">Enable Stream Transcoding</p>
                        <p class="text-xs text-dark-400">Transcode live TV streams for browser playback</p>
                    </div>
                    <label class="relative inline-flex items-center cursor-pointer">
                        <input type="checkbox" id="setting-transcodeStreamEnabled" class="sr-only peer" />
                        <div class="w-11 h-6 bg-dark-600 peer-focus:outline-none rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-primary-500"></div>
                    </label>
                </div>

                <div id="transcode-options" class="space-y-4">
                    <div class="grid grid-cols-2 gap-4">
                        <div>
                            <label class="block text-sm text-dark-400 mb-1">Output Codec</label>
                            <select id="setting-transcodeCodec" class="select">
                                <option value="h264">H.264 (Best compatibility)</option>
                                <option value="hevc">H.265 / HEVC (Smaller files)</option>
                            </select>
                        </div>
                        <div>
                            <label class="block text-sm text-dark-400 mb-1">Hardware Acceleration</label>
                            <select id="setting-transcodeHwAccel" class="select">
                                <option value="auto">Auto-detect</option>
                                <option value="videotoolbox">VideoToolbox (Apple)</option>
                                <option value="nvenc">NVENC (NVIDIA)</option>
                                <option value="amf">AMF (AMD)</option>
                                <option value="vaapi">VAAPI (Linux)</option>
                                <option value="software">Software (CPU)</option>
                            </select>
                        </div>
                    </div>

                    <div class="flex items-center gap-3">
                        <input type="checkbox" id="setting-transcodeSkipCompatible" class="w-4 h-4 text-primary-500 bg-dark-700 border-dark-600 rounded focus:ring-primary-500" />
                        <label for="setting-transcodeSkipCompatible" class="text-sm text-white">Skip already compatible files (H.264/H.265 in MP4)</label>
                    </div>

                    <div class="flex items-center gap-3">
                        <input type="checkbox" id="setting-slowDiskMode" class="w-4 h-4 text-primary-500 bg-dark-700 border-dark-600 rounded focus:ring-primary-500" />
                        <label for="setting-slowDiskMode" class="text-sm text-white">Slow Disk Mode</label>
                        <span class="text-xs text-dark-400">(Sequential: download one file, transcode it, then start next)</span>
                    </div>

                    <!-- Hardware Status Display -->
                    <div id="hw-accel-status" class="p-3 bg-dark-800 rounded-lg text-sm">
                        <span class="text-dark-400">Detecting hardware acceleration...</span>
                    </div>

                    <!-- Transcoder Status -->
                    <div id="transcoder-status" class="hidden p-3 bg-dark-800 rounded-lg">
                        <div class="flex items-center justify-between mb-2">
                            <span class="text-sm text-white font-medium">Transcoding in progress</span>
                            <button onclick="cancelTranscode()" class="text-xs text-red-400 hover:text-red-300">Cancel</button>
                        </div>
                        <div class="text-xs text-dark-300 mb-2" id="transcode-current-title">...</div>
                        <div class="w-full bg-dark-700 rounded-full h-2">
                            <div class="bg-primary-500 h-2 rounded-full transition-all duration-300" id="transcode-progress-bar" style="width: 0%"></div>
                        </div>
                    </div>

                    <!-- Watch Folder Section -->
                    <div class="pt-4 border-t border-dark-700">
                        <div class="flex items-center justify-between mb-3">
                            <div>
                                <p class="text-sm text-white font-medium">Watch Folder</p>
                                <p class="text-xs text-dark-400">Drop files here to transcode and auto-route to movies/series folders</p>
                            </div>
                            <label class="relative inline-flex items-center cursor-pointer">
                                <input type="checkbox" id="setting-transcodeWatchEnabled" class="sr-only peer" />
                                <div class="w-11 h-6 bg-dark-600 peer-focus:outline-none rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-primary-500"></div>
                            </label>
                        </div>
                        <div id="watch-folder-options">
                            <div>
                                <label class="block text-xs text-dark-400 mb-1">Watch Folder Path</label>
                                <input type="text" id="setting-transcodeWatchFolder" class="input" placeholder="/path/to/transcode-input" />
                                <p class="text-xs text-dark-500 mt-1">Series (S01E01) → Series folder | Movies → Movies folder</p>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Language Preferences -->
        <div class="card">
            <div class="p-4 border-b border-dark-700">
                <h2 class="text-lg font-semibold text-white">Language Preferences</h2>
            </div>
            <div class="p-4 space-y-4">
                <p class="text-sm text-dark-400">Select languages for filtering movies, series, and live TV</p>

                <!-- Selected Languages (Badges) -->
                <div id="selected-languages" class="flex flex-wrap gap-2 min-h-[40px] p-3 bg-dark-800 rounded-lg border border-dark-600">
                    <!-- Badges populated by JS -->
                    <span class="text-dark-500 text-sm" id="no-languages-msg">No languages selected</span>
                </div>

                <!-- Add Language Dropdown -->
                <div class="relative">
                    <select id="language-selector" class="select" onchange="addLanguage(this.value)">
                        <option value="">+ Add language...</option>
                    </select>
                </div>
            </div>
        </div>

        <!-- AI / LLM Configuration -->
        <div class="card">
            <div class="p-4 border-b border-dark-700">
                <h2 class="text-lg font-semibold text-white">AI / LLM Configuration</h2>
            </div>
            <div class="p-4 space-y-4">
                <p class="text-sm text-dark-400">Use AI to translate non-English titles and match EPG channels</p>

                <div>
                    <label class="block text-sm text-dark-400 mb-1">LLM Provider</label>
                    <select id="setting-llmProvider" class="select" onchange="updateLLMProviderUI()">
                        <option value="none">Disabled</option>
                        <option value="openai">OpenAI (ChatGPT)</option>
                        <option value="ollama">Ollama (Local)</option>
                    </select>
                </div>

                <!-- OpenAI Settings -->
                <div id="openai-settings" class="space-y-4 hidden">
                    <div>
                        <label class="block text-sm text-dark-400 mb-1">OpenAI API Key</label>
                        <input type="password" id="setting-openaiApiKey" class="input" placeholder="sk-..." />
                        <p class="text-xs text-dark-500 mt-1">Get your key at <a href="https://platform.openai.com/api-keys" target="_blank" class="text-primary-400 hover:underline">platform.openai.com</a></p>
                    </div>
                    <div>
                        <label class="block text-sm text-dark-400 mb-1">Model</label>
                        <select id="setting-openaiModel" class="select">
                            <option value="gpt-4o-mini">GPT-4o Mini (Recommended - $0.15/1M tokens)</option>
                            <option value="gpt-4o">GPT-4o ($2.50/1M tokens)</option>
                            <option value="gpt-3.5-turbo">GPT-3.5 Turbo ($0.50/1M tokens)</option>
                        </select>
                    </div>
                </div>

                <!-- Ollama Settings -->
                <div id="ollama-settings" class="space-y-4 hidden">
                    <div>
                        <label class="block text-sm text-dark-400 mb-1">Ollama Server URL</label>
                        <input type="text" id="setting-ollamaUrl" class="input" placeholder="http://localhost:11434" />
                    </div>
                    <div>
                        <label class="block text-sm text-dark-400 mb-1">Model</label>
                        <input type="text" id="setting-ollamaModel" class="input" placeholder="llama3.2" />
                        <p class="text-xs text-dark-500 mt-1">Run <code class="bg-dark-700 px-1 rounded">ollama list</code> to see available models</p>
                    </div>
                </div>

                <!-- Test Connection Button -->
                <div id="llm-test-section" class="hidden pt-2 border-t border-dark-700">
                    <div class="flex items-center justify-between">
                        <div>
                            <p class="text-sm text-white">Test LLM Connection</p>
                            <p class="text-xs text-dark-400" id="llm-test-status">Click to verify your configuration</p>
                        </div>
                        <button onclick="testLLMConnection()" class="btn btn-secondary btn-sm" id="llm-test-btn">Test</button>
                    </div>
                </div>

                <!-- AI Channel Matching -->
                <div id="llm-channel-match-section" class="hidden pt-2 border-t border-dark-700">
                    <div class="flex items-center justify-between">
                        <div>
                            <p class="text-sm text-white">AI Channel Matching</p>
                            <p class="text-xs text-dark-400">Match EPG channels to IPTV sources using AI</p>
                        </div>
                        <button onclick="matchChannelsWithAI()" class="btn btn-secondary btn-sm" id="channel-match-btn">Match Channels</button>
                    </div>
                    <div id="channel-match-progress" class="hidden mt-3">
                        <div class="flex items-center gap-2">
                            <div class="animate-spin w-4 h-4 border-2 border-primary-500 border-t-transparent rounded-full"></div>
                            <span class="text-sm text-dark-300" id="channel-match-status">Matching channels...</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Security -->
        <div class="card">
            <div class="p-4 border-b border-dark-700">
                <h2 class="text-lg font-semibold text-white">Security</h2>
            </div>
            <div class="p-4 space-y-6">
                <div class="space-y-2">
                    <div class="flex items-center justify-between">
                        <div>
                            <p class="text-sm text-white">User</p>
                            <p class="text-xs text-dark-400" id="auth-username">Loading...</p>
                        </div>
                        <div class="text-xs text-dark-400">MFA: <span id="auth-mfa-status">Loading...</span></div>
                    </div>
                </div>

                <div class="border-t border-dark-700 pt-4 space-y-3" id="mfa-controls">
                    <p class="text-sm text-white">Enable MFA (TOTP)</p>
                    <p class="text-xs text-dark-400">Scan with your authenticator app or enter the secret manually.</p>
                    <div class="flex flex-wrap gap-2">
                        <button onclick="setupTotp()" class="btn btn-secondary btn-sm">Generate Secret</button>
                        <button onclick="enableTotp()" class="btn btn-primary btn-sm">Enable MFA</button>
                    </div>
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                        <div>
                            <label class="block text-xs text-dark-400 mb-1">TOTP Secret</label>
                            <input type="text" id="totp-secret" class="input" readonly />
                        </div>
                        <div>
                            <label class="block text-xs text-dark-400 mb-1">Authenticator Code</label>
                            <input type="text" id="totp-token" class="input" placeholder="123456" />
                        </div>
                    </div>
                    <div>
                        <label class="block text-xs text-dark-400 mb-1">OTPAuth URL</label>
                        <input type="text" id="totp-otpauth" class="input" readonly />
                    </div>
                    <div id="totp-qr-section" class="hidden">
                        <label class="block text-xs text-dark-400 mb-2">QR Code</label>
                        <div class="bg-white p-3 rounded inline-block">
                            <img id="totp-qr" alt="TOTP QR Code" class="w-40 h-40" />
                        </div>
                    </div>
                </div>

                <div class="border-t border-dark-700 pt-4 space-y-3" id="mfa-disable">
                    <p class="text-sm text-white">Disable MFA</p>
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                        <div>
                            <label class="block text-xs text-dark-400 mb-1">Current Password</label>
                            <input type="password" id="mfa-disable-password" class="input" />
                        </div>
                        <div>
                            <label class="block text-xs text-dark-400 mb-1">Authenticator Code</label>
                            <input type="text" id="mfa-disable-token" class="input" placeholder="123456" />
                        </div>
                    </div>
                    <button onclick="disableTotp()" class="btn btn-danger btn-sm">Disable MFA</button>
                </div>
                <div class="border-t border-dark-700 pt-4 space-y-2 hidden" id="mfa-disabled-note">
                    <p class="text-sm text-white">MFA disabled</p>
                    <p class="text-xs text-dark-400">MFA is disabled by configuration (MFA_ENABLED=false).</p>
                </div>

                <div class="border-t border-dark-700 pt-4 space-y-3">
                    <p class="text-sm text-white">Change Password</p>
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                        <div>
                            <label class="block text-xs text-dark-400 mb-1">Current Password</label>
                            <input type="password" id="password-current" class="input" />
                        </div>
                        <div>
                            <label class="block text-xs text-dark-400 mb-1">New Password</label>
                            <input type="password" id="password-new" class="input" />
                        </div>
                    </div>
                    <button onclick="changePassword()" class="btn btn-secondary btn-sm">Update Password</button>
                </div>
            </div>
        </div>

        <!-- Scheduler Status -->
        <div class="card">
            <div class="p-4 border-b border-dark-700">
                <h2 class="text-lg font-semibold text-white">Scheduler</h2>
            </div>
            <div class="p-4 space-y-4">
                <div id="scheduler-status">Loading scheduler status...</div>
            </div>
        </div>

        <!-- Database Maintenance -->
        <div class="card border-red-900/50">
            <div class="p-4 border-b border-red-900/50 bg-red-900/10">
                <h2 class="text-lg font-semibold text-red-400">Database Maintenance</h2>
            </div>
            <div class="p-4 space-y-4">
                <p class="text-sm text-dark-400">
                    If you encounter database schema errors or corruption, you can reset the content database.
                    This will delete all media entries, EPG data, and enrichment cache. Your sources and settings will be preserved.
                    After reset, sync your sources to rebuild the database.
                </p>
                <div class="flex items-center gap-4">
                    <button onclick="resetContentDatabase()" class="btn bg-red-600 hover:bg-red-700 text-white">
                        <svg class="w-4 h-4 mr-2" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"/>
                        </svg>
                        Reset Content Database
                    </button>
                    <span id="db-reset-status" class="text-sm text-dark-400"></span>
                </div>
            </div>
        </div>
    </div>

    <!-- Save Button -->
    <div class="mt-8 flex justify-end">
        <button onclick="saveSettings()" class="btn btn-primary px-8">Save Settings</button>
    </div>
</div>

<!-- Add Source Modal -->
<div id="source-modal" class="modal-overlay hidden">
    <div class="modal-content max-w-md">
        <div class="p-4 border-b border-dark-700">
            <h3 class="text-lg font-semibold text-white" id="modal-title">Add IPTV Source</h3>
        </div>
        <div class="p-4 space-y-4">
            <input type="hidden" id="source-id" />
            <div>
                <label class="block text-sm text-dark-400 mb-1">Name</label>
                <input type="text" id="source-name" class="input" placeholder="My IPTV" />
            </div>
            <div>
                <label class="block text-sm text-dark-400 mb-1">Type</label>
                <select id="source-type" class="select">
                    <option value="xtream">Xtream Codes</option>
                    <option value="m3u">M3U URL</option>
                    <option value="newznab">Newznab Indexer</option>
                </select>
            </div>
            <div>
                <label class="block text-sm text-dark-400 mb-1">URL</label>
                <input type="text" id="source-url" class="input" placeholder="http://server.com" />
            </div>
            <div id="xtream-fields">
                <div class="grid grid-cols-2 gap-4">
                    <div>
                        <label class="block text-sm text-dark-400 mb-1">Username</label>
                        <input type="text" id="source-username" class="input" />
                    </div>
                    <div>
                        <label class="block text-sm text-dark-400 mb-1">Password</label>
                        <input type="password" id="source-password" class="input" />
                    </div>
                </div>
            </div>
            <div id="newznab-fields" class="hidden space-y-4">
                <div>
                    <label class="block text-sm text-dark-400 mb-1">API Key</label>
                    <input type="password" id="source-apikey" class="input" placeholder="Your indexer API key" />
                </div>
                <div>
                    <label class="block text-sm text-dark-400 mb-1">Categories</label>
                    <div class="grid grid-cols-2 gap-2 text-sm">
                        <label class="flex items-center gap-2">
                            <input type="checkbox" id="cat-movies" class="newznab-cat" value="2000" checked />
                            <span class="text-dark-300">Movies (2000)</span>
                        </label>
                        <label class="flex items-center gap-2">
                            <input type="checkbox" id="cat-movies-hd" class="newznab-cat" value="2040" />
                            <span class="text-dark-300">Movies HD (2040)</span>
                        </label>
                        <label class="flex items-center gap-2">
                            <input type="checkbox" id="cat-movies-uhd" class="newznab-cat" value="2045" />
                            <span class="text-dark-300">Movies UHD (2045)</span>
                        </label>
                        <label class="flex items-center gap-2">
                            <input type="checkbox" id="cat-tv" class="newznab-cat" value="5000" checked />
                            <span class="text-dark-300">TV (5000)</span>
                        </label>
                        <label class="flex items-center gap-2">
                            <input type="checkbox" id="cat-tv-hd" class="newznab-cat" value="5040" />
                            <span class="text-dark-300">TV HD (5040)</span>
                        </label>
                        <label class="flex items-center gap-2">
                            <input type="checkbox" id="cat-tv-uhd" class="newznab-cat" value="5045" />
                            <span class="text-dark-300">TV UHD (5045)</span>
                        </label>
                    </div>
                </div>
            </div>
            <div id="iptv-fields">
                <div>
                    <label class="block text-sm text-dark-400 mb-1">EPG URL (Optional)</label>
                    <input type="text" id="source-epg-url" class="input" placeholder="https://epg.example.com/guide.xml.gz" />
                    <p class="text-xs text-dark-500 mt-1">XMLTV format. Leave empty for Xtream sources to auto-generate.</p>
                </div>
                <div>
                    <label class="block text-sm text-dark-400 mb-1">User Agent</label>
                    <input type="text" id="source-useragent" class="input" placeholder="IBOPlayer" value="IBOPlayer" />
                </div>
                <div class="border-t border-dark-700 pt-4 mt-4">
                    <p class="text-sm font-medium text-white mb-3">Device Spoofing (Optional)</p>
                    <p class="text-xs text-dark-500 mb-3">Override global spoofing settings for this source</p>
                    <div class="grid grid-cols-2 gap-4">
                        <div>
                            <label class="block text-sm text-dark-400 mb-1">MAC Address</label>
                            <input type="text" id="source-mac" class="input" placeholder="Leave empty for global" />
                        </div>
                        <div>
                            <label class="block text-sm text-dark-400 mb-1">Device Key</label>
                            <input type="text" id="source-devicekey" class="input" placeholder="Leave empty for global" />
                        </div>
                    </div>
                </div>
                <div class="border-t border-dark-700 pt-4 mt-4">
                    <p class="text-sm font-medium text-white mb-3">Player Simulation</p>
                    <p class="text-xs text-dark-500 mb-3">Throttle downloads to simulate video playback (avoids bans)</p>
                    <div class="flex items-center gap-3 mb-3">
                        <label class="relative inline-flex items-center cursor-pointer">
                            <input type="checkbox" id="source-simulate-playback" class="sr-only peer" checked />
                            <div class="w-11 h-6 bg-dark-600 peer-focus:outline-none rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-primary-500"></div>
                        </label>
                        <span class="text-sm text-dark-300">Enable player simulation</span>
                    </div>
                    <div id="playback-speed-container">
                        <label class="block text-sm text-dark-400 mb-1">Speed Multiplier</label>
                        <select id="source-playback-speed" class="select">
                            <option value="1.0">1.0x (Real-time playback)</option>
                            <option value="1.25">1.25x (Slightly faster)</option>
                            <option value="1.5" selected>1.5x (Recommended)</option>
                            <option value="2.0">2.0x (Double speed)</option>
                            <option value="3.0">3.0x (Triple speed)</option>
                            <option value="0">Disabled (Full speed)</option>
                        </select>
                        <p class="text-xs text-dark-500 mt-1">Higher = faster download but more detectable</p>
                    </div>
                </div>
            </div>
        </div>
        <div class="p-4 border-t border-dark-700 flex justify-end gap-2">
            <button onclick="hideModal()" class="btn btn-secondary">Cancel</button>
            <button onclick="testSource()" class="btn btn-secondary">Test</button>
            <button onclick="saveSource()" class="btn btn-primary">Save</button>
        </div>
    </div>
</div>

<!-- Usenet Provider Modal -->
<div id="usenet-provider-modal" class="modal-overlay hidden">
    <div class="modal-content max-w-md">
        <div class="p-4 border-b border-dark-700">
            <h3 class="text-lg font-semibold text-white" id="usenet-modal-title">Add Usenet Provider</h3>
        </div>
        <div class="p-4 space-y-4">
            <input type="hidden" id="usenet-provider-id" />
            <div>
                <label class="block text-sm text-dark-400 mb-1">Name</label>
                <input type="text" id="usenet-name" class="input" placeholder="Eweka" />
            </div>
            <div class="grid grid-cols-2 gap-4">
                <div>
                    <label class="block text-sm text-dark-400 mb-1">Host</label>
                    <input type="text" id="usenet-host" class="input" placeholder="news.eweka.nl" />
                </div>
                <div>
                    <label class="block text-sm text-dark-400 mb-1">Port</label>
                    <input type="number" id="usenet-port" class="input" value="563" />
                </div>
            </div>
            <div class="grid grid-cols-2 gap-4">
                <div>
                    <label class="block text-sm text-dark-400 mb-1">Username</label>
                    <input type="text" id="usenet-username" class="input" />
                </div>
                <div>
                    <label class="block text-sm text-dark-400 mb-1">Password</label>
                    <input type="password" id="usenet-password" class="input" />
                </div>
            </div>
            <div class="grid grid-cols-2 gap-4">
                <div>
                    <label class="block text-sm text-dark-400 mb-1">Connections</label>
                    <input type="number" id="usenet-connections" class="input" value="10" />
                </div>
                <div>
                    <label class="block text-sm text-dark-400 mb-1">Priority</label>
                    <input type="number" id="usenet-priority" class="input" value="0" />
                    <p class="text-xs text-dark-500 mt-1">Higher = try first</p>
                </div>
            </div>
            <div class="flex items-center gap-3">
                <label class="relative inline-flex items-center cursor-pointer">
                    <input type="checkbox" id="usenet-ssl" class="sr-only peer" checked />
                    <div class="w-11 h-6 bg-dark-600 peer-focus:outline-none rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-primary-500"></div>
                </label>
                <span class="text-sm text-dark-300">Use SSL/TLS</span>
            </div>
        </div>
        <div class="p-4 border-t border-dark-700 flex justify-end gap-2">
            <button onclick="hideUsenetModal()" class="btn btn-secondary">Cancel</button>
            <button onclick="testUsenetProvider()" class="btn btn-secondary">Test</button>
            <button onclick="saveUsenetProvider()" class="btn btn-primary">Save</button>
        </div>
    </div>
</div>

<style>
/* Wizard Step Styles */
.wizard-step {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 0.5rem;
}
.wizard-step-circle {
    width: 2rem;
    height: 2rem;
    border-radius: 50%;
    background: var(--dark-700);
    color: var(--dark-400);
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 0.875rem;
    font-weight: 500;
    transition: all 0.2s;
}
.wizard-step-circle.active {
    background: var(--primary-500);
    color: white;
}
.wizard-step-circle.completed {
    background: var(--green-500);
    color: white;
}
.wizard-step-label {
    font-size: 0.75rem;
    color: var(--dark-400);
    white-space: nowrap;
}
.wizard-step.active .wizard-step-label {
    color: white;
}
.wizard-step-line {
    flex: 1;
    height: 2px;
    background: var(--dark-700);
    margin: 0 0.5rem;
    margin-bottom: 1.5rem;
}
.wizard-step-line.completed {
    background: var(--green-500);
}
/* Wizard Step Content */
.wizard-step-content {
    display: none;
}
.wizard-step-content.active {
    display: block;
}
/* EPG Matching Styles */
.epg-channel-row {
    display: flex;
    align-items: center;
    gap: 1rem;
    padding: 0.75rem;
    border-bottom: 1px solid var(--dark-700);
}
.epg-channel-row:hover {
    background: var(--dark-800);
}
.epg-channel-name {
    flex: 1;
    font-size: 0.875rem;
}
.epg-match-select {
    width: 200px;
}
.epg-match-badge {
    font-size: 0.75rem;
    padding: 0.125rem 0.5rem;
    border-radius: 9999px;
}
.epg-match-badge.matched {
    background: var(--green-500)/20;
    color: var(--green-300);
}
.epg-match-badge.unmatched {
    background: var(--yellow-500)/20;
    color: var(--yellow-300);
}
</style>

<script>
    // Socket is initialized globally in app.js (loaded via footer)

    const settingKeys = ['tempPath', 'movieDownloadPath', 'seriesDownloadPath', 'recordingsPath', 'tmdbApiKey', 'plexUrl', 'plexToken', 'plexMovieLibraryId', 'plexTvLibraryId', 'overseerrUrl', 'overseerrApiKey', 'webhookUrl', 'telegramBotToken', 'telegramChatId', 'maxConcurrentDownloads', 'downloadRetries', 'downloadDelayMin', 'downloadDelayMax', 'spoofedMac', 'spoofedDeviceKey', 'epgSyncHour', 'transcodeCodec', 'transcodeHwAccel', 'transcodeWatchFolder', 'llmProvider', 'openaiApiKey', 'openaiModel', 'ollamaUrl', 'ollamaModel', 'hdhrFriendlyName', 'hdhrTunerCount', 'hdhrBaseUrl', 'hdhrSourceId'];
    const booleanSettingKeys = ['transcodeFilesEnabled', 'transcodeStreamEnabled', 'transcodeSkipCompatible', 'transcodeWatchEnabled', 'slowDiskMode', 'telegramEnabled'];

    // LLM UI Functions
    function updateLLMProviderUI() {
        const provider = document.getElementById('setting-llmProvider').value;
        const openaiSettings = document.getElementById('openai-settings');
        const ollamaSettings = document.getElementById('ollama-settings');
        const testSection = document.getElementById('llm-test-section');
        const channelMatchSection = document.getElementById('llm-channel-match-section');

        // Hide all provider-specific settings
        openaiSettings.classList.add('hidden');
        ollamaSettings.classList.add('hidden');

        if (provider === 'none') {
            testSection.classList.add('hidden');
            channelMatchSection.classList.add('hidden');
        } else {
            testSection.classList.remove('hidden');
            channelMatchSection.classList.remove('hidden');

            if (provider === 'openai') {
                openaiSettings.classList.remove('hidden');
            } else if (provider === 'ollama') {
                ollamaSettings.classList.remove('hidden');
            }
        }
    }

    async function testLLMConnection() {
        const btn = document.getElementById('llm-test-btn');
        const statusEl = document.getElementById('llm-test-status');

        btn.disabled = true;
        statusEl.textContent = 'Testing connection...';

        try {
            // First save settings
            await saveSettings();

            const response = await fetch('/api/llm/test', { method: 'POST' });
            const result = await response.json();

            if (result.success) {
                statusEl.innerHTML = '<span class="text-green-400">Connected!</span> Provider: ' + result.provider + ', Model: ' + result.model;
                if (window.showToast) showToast('LLM connection successful!', 'success');
            } else {
                statusEl.innerHTML = '<span class="text-red-400">Failed:</span> ' + (result.error || 'Unknown error');
                if (window.showToast) showToast('LLM connection failed: ' + result.error, 'error');
            }
        } catch (err) {
            statusEl.innerHTML = '<span class="text-red-400">Error:</span> ' + err.message;
            if (window.showToast) showToast('LLM test failed: ' + err.message, 'error');
        } finally {
            btn.disabled = false;
        }
    }

    async function matchChannelsWithAI() {
        const btn = document.getElementById('channel-match-btn');
        const progressDiv = document.getElementById('channel-match-progress');
        const statusEl = document.getElementById('channel-match-status');

        btn.disabled = true;
        progressDiv.classList.remove('hidden');
        statusEl.textContent = 'Matching channels with AI...';

        try {
            const response = await fetch('/api/epg/match-channels', { method: 'POST' });
            const result = await response.json();

            if (result.skipped) {
                statusEl.textContent = 'LLM not configured';
                if (window.showToast) showToast('Please configure LLM first', 'warning');
            } else {
                statusEl.textContent = 'Matched ' + result.matched + ' channels';
                if (window.showToast) showToast('Matched ' + result.matched + ' channels', 'success');
            }
        } catch (err) {
            statusEl.textContent = 'Error: ' + err.message;
            if (window.showToast) showToast('Channel matching failed: ' + err.message, 'error');
        } finally {
            btn.disabled = false;
            setTimeout(() => progressDiv.classList.add('hidden'), 3000);
        }
    }

    // Common language codes
    const LANGUAGES = [
        { code: 'de', name: 'German' },
        { code: 'en', name: 'English' },
        { code: 'fr', name: 'French' },
        { code: 'es', name: 'Spanish' },
        { code: 'it', name: 'Italian' },
        { code: 'pt', name: 'Portuguese' },
        { code: 'nl', name: 'Dutch' },
        { code: 'pl', name: 'Polish' },
        { code: 'ru', name: 'Russian' },
        { code: 'tr', name: 'Turkish' },
        { code: 'ar', name: 'Arabic' },
        { code: 'ja', name: 'Japanese' },
        { code: 'ko', name: 'Korean' },
        { code: 'zh', name: 'Chinese' }
    ];

    let selectedLanguages = [];

    // Track which enrichment is running
    let activeEnrichment = null;

    // Initialize socket listeners when DOM is ready (socket from app.js)
    document.addEventListener('DOMContentLoaded', () => {
        // Enrichment queue events
        socket.on('enrichment:queued', (data) => {
            if (window.showToast) showToast('Queued ' + data.added + ' items for enrichment', 'info');
        });

        socket.on('enrichment:workers:started', (data) => {
            const btn = document.getElementById('enrich-btn');
            const stopBtn = document.getElementById('enrich-stop-btn');
            const progressDiv = document.getElementById('enrich-progress');
            if (btn) btn.classList.add('hidden');
            if (stopBtn) stopBtn.classList.remove('hidden');
            if (progressDiv) progressDiv.classList.remove('hidden');
            updateWorkerIndicators(data.count);
        });

        socket.on('enrichment:progress', (data) => {
            const progressDiv = document.getElementById('enrich-progress');
            const statusEl = document.getElementById('enrich-status');
            const barEl = document.getElementById('enrich-bar');
            const rateEl = document.getElementById('enrich-rate');
            const pendingEl = document.getElementById('enrich-pending');
            const processingEl = document.getElementById('enrich-processing');
            const completedEl = document.getElementById('enrich-completed');
            const failedEl = document.getElementById('enrich-failed');

            const q = data.queue || {};
            const completed = (q.completed || 0) + (q.failed || 0);
            const total = q.total || 1;

            if (progressDiv) progressDiv.classList.remove('hidden');
            if (statusEl) statusEl.textContent = 'Enriching... ' + completed + '/' + total;

            const percent = Math.round((completed / total) * 100);
            if (barEl) barEl.style.width = percent + '%';

            // Calculate rate from workers
            const workers = data.workers || [];
            const totalProcessed = workers.reduce((sum, w) => sum + (w.processed || 0) + (w.failed || 0), 0);
            if (rateEl) rateEl.textContent = workers.length + ' workers active';

            if (pendingEl) pendingEl.textContent = q.pending || 0;
            if (processingEl) processingEl.textContent = q.processing || 0;
            if (completedEl) completedEl.textContent = q.completed || 0;
            if (failedEl) failedEl.textContent = q.failed || 0;
        });

        socket.on('enrichment:workers:stopped', (data) => {
            const btn = document.getElementById('enrich-btn');
            const stopBtn = document.getElementById('enrich-stop-btn');
            const progressDiv = document.getElementById('enrich-progress');
            const statusEl = document.getElementById('enrich-status');

            if (btn) btn.classList.remove('hidden');
            if (stopBtn) stopBtn.classList.add('hidden');
            if (statusEl) statusEl.textContent = 'Completed';

            setTimeout(() => {
                if (progressDiv) progressDiv.classList.add('hidden');
                loadEnrichStats();
            }, 3000);
        });

        // Legacy enrich events (for Overseerr)
        socket.on('enrich:start', (data) => {
            if (data.source === 'overseerr') {
                const progressDiv = document.getElementById('overseerr-enrich-progress');
                const statusEl = document.getElementById('overseerr-enrich-status');
                const barEl = document.getElementById('overseerr-enrich-bar');
                if (progressDiv) progressDiv.classList.remove('hidden');
                if (statusEl) statusEl.textContent = 'Starting... (0/' + data.total + ')';
                if (barEl) barEl.style.width = '0%';
            }
        });

        socket.on('enrich:progress', (data) => {
            if (data.source === 'overseerr') {
                const statusEl = document.getElementById('overseerr-enrich-status');
                const barEl = document.getElementById('overseerr-enrich-bar');
                if (statusEl) statusEl.textContent = data.current + '/' + data.total + ' (' + data.success + ' success, ' + data.failed + ' failed)';
                if (barEl) barEl.style.width = Math.round((data.current / data.total) * 100) + '%';
            }
        });

        socket.on('enrich:complete', (data) => {
            if (data.source === 'overseerr') {
                const progressDiv = document.getElementById('overseerr-enrich-progress');
                const statusEl = document.getElementById('overseerr-enrich-status');
                const btn = document.getElementById('overseerr-enrich-btn');
                if (statusEl) statusEl.textContent = 'Complete: ' + data.success + ' success, ' + data.failed + ' failed';
                if (btn) btn.disabled = false;
                setTimeout(() => {
                    if (progressDiv) progressDiv.classList.add('hidden');
                    loadEnrichStats();
                }, 3000);
            }
        });

        // Initialize settings
        loadSettings();
        loadSources();
        loadEnrichStats();
        loadEnrichmentQueueStatus();
        loadSchedulerStatus();
        checkFfmpeg();
        loadTranscoderHwStatus();

        // Transcoder socket events
        socket.on('transcode:start', (data) => {
            document.getElementById('transcoder-status').classList.remove('hidden');
            document.getElementById('transcode-current-title').textContent = data.title || 'Processing...';
            document.getElementById('transcode-progress-bar').style.width = '0%';
        });

        socket.on('transcode:progress', (data) => {
            document.getElementById('transcoder-status').classList.remove('hidden');
            document.getElementById('transcode-current-title').textContent = data.title || 'Processing...';
            document.getElementById('transcode-progress-bar').style.width = (data.progress || 0) + '%';
        });

        socket.on('transcode:complete', (data) => {
            document.getElementById('transcoder-status').classList.add('hidden');
            if (window.showToast) showToast('Transcoding complete: ' + data.title, 'success');
        });

        socket.on('transcode:failed', (data) => {
            document.getElementById('transcoder-status').classList.add('hidden');
            if (window.showToast) showToast('Transcoding failed: ' + data.error, 'error');
        });

        socket.on('transcode:skipped', (data) => {
            if (window.showToast) showToast('File already compatible: ' + data.title, 'info');
        });

        // Toggle transcode options visibility on checkbox change
        document.getElementById('setting-transcodeFilesEnabled').addEventListener('change', updateTranscodeOptionsVisibility);
        document.getElementById('setting-transcodeStreamEnabled').addEventListener('change', updateTranscodeOptionsVisibility);
        document.getElementById('setting-transcodeWatchEnabled').addEventListener('change', updateWatchFolderOptionsVisibility);
    });

    // Render language badges
    function renderLanguageBadges() {
        const container = document.getElementById('selected-languages');
        const noMsg = document.getElementById('no-languages-msg');

        if (selectedLanguages.length === 0) {
            container.innerHTML = '<span class="text-dark-500 text-sm" id="no-languages-msg">No languages selected</span>';
            return;
        }

        container.innerHTML = selectedLanguages.map(code => {
            const lang = LANGUAGES.find(l => l.code === code);
            const name = lang ? lang.name : code;
            return \`
                <span class="inline-flex items-center gap-1 px-3 py-1 rounded-full bg-primary-500/20 text-primary-400 text-sm">
                    \${name}
                    <button onclick="removeLanguage('\${code}')" class="hover:text-white ml-1">&times;</button>
                </span>
            \`;
        }).join('');

        // Update dropdown to exclude already selected
        populateLanguageDropdown();
    }

    function populateLanguageDropdown() {
        const selector = document.getElementById('language-selector');
        const available = LANGUAGES.filter(l => !selectedLanguages.includes(l.code));
        selector.innerHTML = '<option value="">+ Add language...</option>' +
            available.map(l => \`<option value="\${l.code}">\${l.name}</option>\`).join('');
    }

    function addLanguage(code) {
        if (!code || selectedLanguages.includes(code)) return;
        selectedLanguages.push(code);
        renderLanguageBadges();
        document.getElementById('language-selector').value = '';
    }

    function removeLanguage(code) {
        selectedLanguages = selectedLanguages.filter(c => c !== code);
        renderLanguageBadges();
    }

    // Render EPG country badges
    function renderCountryBadges() {
        const container = document.getElementById('selected-countries');

        if (selectedEpgCountries.length === 0) {
            container.innerHTML = '<span class="text-dark-500 text-sm" id="no-countries-msg">No countries selected</span>';
            return;
        }

        container.innerHTML = selectedEpgCountries.map(country => \`
            <span class="inline-flex items-center gap-1 px-3 py-1 rounded-full bg-green-500/20 text-green-400 text-sm">
                \${country}
                <button onclick="removeCountry('\${country}')" class="hover:text-white ml-1">&times;</button>
            </span>
        \`).join('');

        // Update dropdown to exclude already selected
        populateCountryDropdown();
    }

    function populateCountryDropdown() {
        const selector = document.getElementById('country-selector');
        const available = availableEpgCountries.filter(c => !selectedEpgCountries.includes(c));
        selector.innerHTML = '<option value="">+ Add country...</option>' +
            available.map(c => \`<option value="\${c}">\${c}</option>\`).join('');
    }

    function addCountry(country) {
        if (!country || selectedEpgCountries.includes(country)) return;
        selectedEpgCountries.push(country);
        renderCountryBadges();
        document.getElementById('country-selector').value = '';
    }

    function removeCountry(country) {
        selectedEpgCountries = selectedEpgCountries.filter(c => c !== country);
        renderCountryBadges();
    }

    async function loadEpgCountries() {
        try {
            const response = await fetch('/api/epg/countries');
            availableEpgCountries = await response.json();
            renderCountryBadges();
        } catch (err) {
            console.error('Failed to load EPG countries:', err);
        }
    }

    async function fetchJsonSafe(url, options) {
        const response = await fetch(url, options);
        const contentType = response.headers.get('content-type') || '';
        if (!contentType.includes('application/json')) {
            const text = await response.text();
            throw new Error(text || 'Unexpected response (' + response.status + ')');
        }
        const data = await response.json();
        if (!response.ok) {
            const message = data?.error || 'Request failed (' + response.status + ')';
            throw new Error(message);
        }
        return data;
    }

    async function syncGlobalEpg() {
        try {
            // Save current EPG country selection first
            await fetch('/api/settings', {
                method: 'PUT',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ epgCountries: selectedEpgCountries })
            });

            const result = await fetchJsonSafe('/api/epg/sync-all', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ countries: selectedEpgCountries })
            });
            if (!result.success) throw new Error(result.error);
        } catch (err) {
            console.error('Failed to sync EPG:', err);
            if (window.showToast) showToast('Failed to sync EPG: ' + err.message, 'error');
        }
    }

    async function loadSchedulerStatus() {
        try {
            const response = await fetch('/api/scheduler/status');
            const status = await response.json();
            const container = document.getElementById('scheduler-status');

            let html = '<div class="space-y-2">';
            html += \`<p class="text-sm"><span class="text-dark-400">Status:</span> <span class="text-\${status.running ? 'green' : 'red'}-400">\${status.running ? 'Running' : 'Stopped'}</span></p>\`;
            html += \`<p class="text-sm"><span class="text-dark-400">Active Recordings:</span> \${status.activeRecordings}</p>\`;

            if (status.upcomingRecordings && status.upcomingRecordings.length > 0) {
                html += '<p class="text-sm text-dark-400 mt-2">Upcoming Recordings:</p>';
                html += '<ul class="text-sm space-y-1 ml-4">';
                for (const rec of status.upcomingRecordings.slice(0, 5)) {
                    const start = new Date(rec.start_time).toLocaleString();
                    html += \`<li class="text-dark-300">• \${rec.title} - \${start}</li>\`;
                }
                html += '</ul>';
            }

            if (status.tasks && status.tasks.length > 0) {
                html += '<p class="text-sm text-dark-400 mt-2">Scheduled Tasks:</p>';
                html += '<ul class="text-sm space-y-1 ml-4">';
                for (const task of status.tasks) {
                    const nextRun = new Date(task.next_run).toLocaleString();
                    html += \`<li class="text-dark-300">• \${task.task_type} - next: \${nextRun}</li>\`;
                }
                html += '</ul>';
            }

            html += '</div>';
            container.innerHTML = html;
        } catch (err) {
            console.error('Failed to load scheduler status:', err);
            document.getElementById('scheduler-status').textContent = 'Failed to load status';
        }
    }

    async function resetContentDatabase() {
        const confirmed = confirm('WARNING: This will delete ALL media entries, EPG data, and enrichment cache. Your sources and settings will be preserved. You will need to sync your sources again to rebuild the database. Are you sure you want to continue?');

        if (!confirmed) return;

        const statusEl = document.getElementById('db-reset-status');
        statusEl.textContent = 'Resetting database...';
        statusEl.className = 'text-sm text-yellow-400';

        try {
            const response = await fetch('/api/db/reset-content', { method: 'POST' });
            const result = await response.json();

            if (result.success) {
                statusEl.textContent = 'Database reset complete. Please sync your sources.';
                statusEl.className = 'text-sm text-green-400';
                if (window.showToast) {
                    showToast('Content database reset successfully', 'success');
                }
            } else {
                throw new Error(result.error || 'Reset failed');
            }
        } catch (err) {
            console.error('Database reset failed:', err);
            statusEl.textContent = 'Reset failed: ' + err.message;
            statusEl.className = 'text-sm text-red-400';
            if (window.showToast) {
                showToast('Database reset failed: ' + err.message, 'error');
            }
        }
    }

    async function checkFfmpeg() {
        try {
            const response = await fetch('/api/scheduler/ffmpeg');
            const result = await response.json();
            const container = document.getElementById('ffmpeg-status');
            if (result.available) {
                container.innerHTML = '<span class="text-green-400">ffmpeg found:</span> ' + result.path;
            } else {
                container.innerHTML = '<span class="text-yellow-400">ffmpeg not found</span> - required for recording';
            }
        } catch (err) {
            console.error('Failed to check ffmpeg:', err);
        }
    }

    async function loadTranscoderHwStatus() {
        try {
            const response = await fetch('/api/transcoder/hw-status');
            const result = await response.json();
            const container = document.getElementById('hw-accel-status');
            if (!container) return;

            const typeLabels = {
                'videotoolbox': 'VideoToolbox (Apple Silicon)',
                'nvenc': 'NVENC (NVIDIA GPU)',
                'amf': 'AMF (AMD GPU)',
                'vaapi': 'VAAPI (Linux)',
                'software': 'Software (CPU)',
                'unavailable': 'Not Available'
            };

            const typeName = typeLabels[result.type] || result.type;
            const isHwAccel = result.available && result.type !== 'software';

            let html = '<div class="flex items-center gap-2">';
            html += '<span class="w-2 h-2 rounded-full ' + (isHwAccel ? 'bg-green-500' : 'bg-yellow-500') + '"></span>';
            html += '<span class="text-white font-medium">' + typeName + '</span>';
            html += '</div>';

            if (result.encoders) {
                html += '<div class="text-xs text-dark-400 mt-1">';
                html += 'H.264: ' + (result.encoders.h264 || 'N/A');
                if (result.encoders.hevc) {
                    html += ' | HEVC: ' + result.encoders.hevc;
                }
                html += '</div>';
            }

            container.innerHTML = html;
        } catch (err) {
            console.error('Failed to load transcoder HW status:', err);
            const container = document.getElementById('hw-accel-status');
            if (container) {
                container.innerHTML = '<span class="text-dark-400">Could not detect hardware acceleration</span>';
            }
        }
    }

    async function cancelTranscode() {
        if (!confirm('Cancel the current transcoding job?')) return;
        try {
            await fetch('/api/transcoder/cancel', { method: 'POST' });
            document.getElementById('transcoder-status').classList.add('hidden');
            if (window.showToast) showToast('Transcoding cancelled', 'info');
        } catch (err) {
            console.error('Failed to cancel transcode:', err);
            if (window.showToast) showToast('Failed to cancel: ' + err.message, 'error');
        }
    }

    async function loadSettings() {
        try {
            const response = await fetch('/api/settings');
            const settings = await response.json();
            settingKeys.forEach(key => {
                const el = document.getElementById('setting-' + key);
                if (el && settings[key] !== undefined) el.value = settings[key];
            });
            // Handle boolean/checkbox settings
            booleanSettingKeys.forEach(key => {
                const el = document.getElementById('setting-' + key);
                if (el && settings[key] !== undefined) el.checked = settings[key];
            });
            document.getElementById('webhook-url').textContent = window.location.origin + '/api/webhooks/overseerr';

            // Load language preferences
            selectedLanguages = settings.preferredLanguages || ['de', 'en'];
            renderLanguageBadges();

            // Update transcode options visibility
            updateTranscodeOptionsVisibility();
            updateWatchFolderOptionsVisibility();

            // Update LLM provider UI
            updateLLMProviderUI();

            // Populate HDHR source dropdown
            await populateHdhrSources(settings.hdhrSourceId);
        } catch (err) {
            console.error('Failed to load settings:', err);
        }
    }

    async function populateHdhrSources(selectedSourceId) {
        try {
            const response = await fetch('/api/sources');
            const sources = await response.json();
            const select = document.getElementById('setting-hdhrSourceId');
            if (!select) return;

            // Clear existing options except the first one
            select.innerHTML = '<option value="">All sources (no filter)</option>';

            // Add source options
            sources.forEach(source => {
                const opt = document.createElement('option');
                opt.value = source.id;
                opt.textContent = source.name + (source.epg_url ? ' (has EPG)' : '');
                if (selectedSourceId && source.id == selectedSourceId) {
                    opt.selected = true;
                }
                select.appendChild(opt);
            });
        } catch (err) {
            console.error('Failed to load sources for HDHR:', err);
        }
    }

    function updateTranscodeOptionsVisibility() {
        const filesEnabled = document.getElementById('setting-transcodeFilesEnabled').checked;
        const streamEnabled = document.getElementById('setting-transcodeStreamEnabled').checked;
        const enabled = filesEnabled || streamEnabled;
        const optionsEl = document.getElementById('transcode-options');
        if (optionsEl) {
            optionsEl.style.opacity = enabled ? '1' : '0.5';
            optionsEl.style.pointerEvents = enabled ? 'auto' : 'none';
        }
    }

    function updateWatchFolderOptionsVisibility() {
        const enabled = document.getElementById('setting-transcodeWatchEnabled').checked;
        const optionsEl = document.getElementById('watch-folder-options');
        if (optionsEl) {
            optionsEl.style.opacity = enabled ? '1' : '0.5';
            optionsEl.style.pointerEvents = enabled ? 'auto' : 'none';
        }
    }

    async function saveSettings() {
        const settings = {};
        settingKeys.forEach(key => {
            const el = document.getElementById('setting-' + key);
            if (el) {
                settings[key] = el.type === 'number' ? parseInt(el.value) : el.value;
            }
        });
        // Handle boolean/checkbox settings
        booleanSettingKeys.forEach(key => {
            const el = document.getElementById('setting-' + key);
            if (el) {
                settings[key] = el.checked;
            }
        });

        // Add language preferences
        settings.preferredLanguages = selectedLanguages;

        // Handle hdhrSourceId - convert to integer or null
        if (settings.hdhrSourceId === '' || settings.hdhrSourceId === undefined) {
            settings.hdhrSourceId = null;
        } else {
            settings.hdhrSourceId = parseInt(settings.hdhrSourceId);
        }

        try {
            await fetch('/api/settings', {
                method: 'PUT',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(settings)
            });
            if (window.showToast) {
                showToast('Settings saved!', 'success');
            } else {
                alert('Settings saved!');
            }
        } catch (err) {
            console.error('Failed to save settings:', err);
            if (window.showToast) {
                showToast('Failed to save settings', 'error');
            } else {
                alert('Failed to save settings');
            }
        }
    }

    async function loadSources() {
        try {
            const response = await fetch('/api/sources');
            const sources = await response.json();
            const container = document.getElementById('sources-list');
            if (sources.length === 0) {
                container.innerHTML = '<p class="text-dark-400 text-center py-8">No sources configured</p>';
                return;
            }
            container.innerHTML = sources.map(s => \`
                <div class="p-4 border-b border-dark-700 \${s.active ? '' : 'opacity-50'}" id="source-row-\${s.id}">
                    <div class="flex items-start justify-between gap-4">
                        <div class="min-w-0 flex-1">
                            <h3 class="font-medium text-white">\${s.name}</h3>
                            <p class="text-sm text-dark-400">\${s.type} • <span id="source-status-\${s.id}" class="\${s.active ? 'text-green-400' : 'text-red-400'}">\${s.active ? 'Active' : 'Disabled'}</span></p>
                            <p class="text-xs text-dark-500">\${s.last_sync ? 'Last sync: ' + new Date(s.last_sync).toLocaleString() : 'Never synced'}</p>
                        </div>
                        <div class="flex gap-2 flex-shrink-0" id="source-buttons-\${s.id}">
                            <button onclick="toggleSource(\${s.id})" class="btn \${s.active ? 'btn-secondary' : 'btn-success'} btn-sm" id="toggle-btn-\${s.id}" title="\${s.active ? 'Disable source' : 'Enable source'}">
                                \${s.active ?
                                    '<svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13.875 18.825A10.05 10.05 0 0112 19c-4.478 0-8.268-2.943-9.543-7a9.97 9.97 0 011.563-3.029m5.858.908a3 3 0 114.243 4.243M9.878 9.878l4.242 4.242M9.88 9.88l-3.29-3.29m7.532 7.532l3.29 3.29M3 3l3.59 3.59m0 0A9.953 9.953 0 0112 5c4.478 0 8.268 2.943 9.542 7a10.025 10.025 0 01-4.132 5.411m0 0L21 21"></path></svg>' :
                                    '<svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"></path><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z"></path></svg>'
                                }
                            </button>
                            <button onclick="reprocessTitles(\${s.id})" class="btn btn-secondary btn-sm" id="reprocess-btn-\${s.id}" title="Clean titles (extract year, quality, language, platform)">
                                <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 21a4 4 0 01-4-4V5a2 2 0 012-2h4a2 2 0 012 2v12a4 4 0 01-4 4zm0 0h12a2 2 0 002-2v-4a2 2 0 00-2-2h-2.343M11 7.343l1.657-1.657a2 2 0 012.828 0l2.829 2.829a2 2 0 010 2.828l-8.486 8.485M7 17h.01"></path></svg>
                            </button>
                            <button onclick="enrichSource(\${s.id})" class="btn btn-secondary btn-sm" id="enrich-btn-\${s.id}" title="Enrich with TMDB posters">
                                <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z"></path></svg>
                            </button>
                            <button onclick="syncSource(\${s.id})" class="btn btn-secondary btn-sm" id="sync-btn-\${s.id}">Sync</button>
                            <button onclick="syncSourceEpg(\${s.id})" class="btn btn-secondary btn-sm" id="epg-btn-\${s.id}" title="Refresh EPG data">EPG</button>
                            <button onclick="editSource(\${s.id})" class="btn btn-secondary btn-sm">Edit</button>
                            <button onclick="deleteSource(\${s.id})" class="btn btn-danger btn-sm">Delete</button>
                        </div>
                    </div>
                    <!-- Stats row -->
                    <div class="grid grid-cols-5 gap-2 mt-3 pt-3 border-t border-dark-700 text-xs" id="source-stats-\${s.id}">
                        <span class="text-dark-500">Loading stats...</span>
                    </div>
                    <!-- Sync progress bar -->
                    <div id="sync-progress-\${s.id}" class="hidden mt-3">
                        <div class="flex items-center gap-2 mb-2">
                            <div class="animate-spin w-4 h-4 border-2 border-primary-500 border-t-transparent rounded-full"></div>
                            <span class="text-sm text-dark-300" id="sync-status-\${s.id}">Starting sync...</span>
                        </div>
                        <div class="w-full bg-dark-700 rounded-full h-2">
                            <div class="bg-primary-500 h-2 rounded-full transition-all duration-300" id="sync-bar-\${s.id}" style="width: 0%"></div>
                        </div>
                    </div>
                    <!-- Download progress bar -->
                    <div id="download-progress-\${s.id}" class="hidden mt-3">
                        <div class="flex items-center justify-between mb-1">
                            <span class="text-xs text-dark-400">Downloading:</span>
                            <span class="text-xs text-dark-300" id="download-title-\${s.id}">...</span>
                        </div>
                        <div class="w-full bg-dark-700 rounded-full h-1.5">
                            <div class="bg-green-500 h-1.5 rounded-full transition-all duration-300" id="download-bar-\${s.id}" style="width: 0%"></div>
                        </div>
                    </div>
                    <!-- Enrichment progress bar -->
                    <div id="enrich-progress-\${s.id}" class="hidden mt-3">
                        <div class="flex items-center gap-2 mb-1">
                            <div class="animate-spin w-3 h-3 border-2 border-purple-500 border-t-transparent rounded-full"></div>
                            <span class="text-xs text-dark-300" id="enrich-status-\${s.id}">Enriching...</span>
                        </div>
                        <div class="w-full bg-dark-700 rounded-full h-1.5">
                            <div class="bg-purple-500 h-1.5 rounded-full transition-all duration-300" id="enrich-bar-\${s.id}" style="width: 0%"></div>
                        </div>
                    </div>
                    <!-- EPG progress bar -->
                    <div id="epg-progress-\${s.id}" class="hidden mt-3">
                        <div class="flex items-center gap-2 mb-1">
                            <div class="animate-spin w-3 h-3 border-2 border-blue-500 border-t-transparent rounded-full"></div>
                            <span class="text-xs text-dark-300" id="epg-status-\${s.id}">Syncing EPG...</span>
                        </div>
                        <div class="w-full bg-dark-700 rounded-full h-1.5">
                            <div class="bg-blue-500 h-1.5 rounded-full transition-all duration-300" id="epg-bar-\${s.id}" style="width: 0%"></div>
                        </div>
                    </div>
                </div>
            \`).join('');

            // Load stats for each source
            sources.forEach(s => loadSourceStats(s.id));

        } catch (err) {
            console.error('Failed to load sources:', err);
        }
    }

    function showAddSource() {
        document.getElementById('modal-title').textContent = 'Add IPTV Source';
        document.getElementById('source-id').value = '';
        document.getElementById('source-name').value = '';
        document.getElementById('source-type').value = 'xtream';
        document.getElementById('source-url').value = '';
        // IPTV fields
        document.getElementById('source-username').value = '';
        document.getElementById('source-password').value = '';
        document.getElementById('source-useragent').value = 'IBOPlayer';
        document.getElementById('source-epg-url').value = '';
        document.getElementById('source-mac').value = '';
        document.getElementById('source-devicekey').value = '';
        document.getElementById('source-simulate-playback').checked = true;
        document.getElementById('source-playback-speed').value = '1.5';
        document.getElementById('playback-speed-container').style.display = 'block';
        // Newznab fields
        document.getElementById('source-apikey').value = '';
        document.querySelectorAll('.newznab-cat').forEach(cb => {
            cb.checked = cb.value === '2000' || cb.value === '5000';
        });
        // Show xtream fields by default (since type defaults to xtream)
        document.getElementById('xtream-fields').style.display = 'block';
        document.getElementById('newznab-fields').style.display = 'none';
        document.getElementById('iptv-fields').style.display = 'block';
        document.getElementById('source-modal').classList.remove('hidden');
    }

    function hideModal() {
        document.getElementById('source-modal').classList.add('hidden');
    }

    async function saveSource() {
        const id = document.getElementById('source-id').value;
        const type = document.getElementById('source-type').value;

        const data = {
            name: document.getElementById('source-name').value,
            type: type,
            url: document.getElementById('source-url').value
        };

        if (type === 'newznab') {
            // Collect selected categories
            const categories = [];
            document.querySelectorAll('.newznab-cat:checked').forEach(cb => {
                categories.push(parseInt(cb.value));
            });
            data.indexer_config = JSON.stringify({
                apiKey: document.getElementById('source-apikey').value,
                categories: categories
            });
        } else {
            // IPTV source fields
            data.username = document.getElementById('source-username').value;
            data.password = document.getElementById('source-password').value;
            data.user_agent = document.getElementById('source-useragent').value;
            data.epg_url = document.getElementById('source-epg-url').value || null;
            data.spoofed_mac = document.getElementById('source-mac').value || null;
            data.spoofed_device_key = document.getElementById('source-devicekey').value || null;
            data.simulate_playback = document.getElementById('source-simulate-playback').checked ? 1 : 0;
            data.playback_speed_multiplier = parseFloat(document.getElementById('source-playback-speed').value);
        }

        try {
            const response = await fetch(id ? '/api/sources/' + id : '/api/sources', {
                method: id ? 'PUT' : 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(data)
            });
            if (!response.ok) {
                const errorData = await response.json().catch(() => ({}));
                throw new Error(errorData.error || 'Server returned ' + response.status);
            }
            hideModal();
            loadSources();
        } catch (err) {
            console.error('Failed to save source:', err);
            alert('Failed to save source: ' + err.message);
        }
    }

    async function editSource(id) {
        try {
            const response = await fetch('/api/sources');
            const sources = await response.json();
            const source = sources.find(s => s.id === id);
            if (!source) return alert('Source not found');

            const isNewznab = source.type === 'newznab';
            const isIptv = source.type === 'xtream' || source.type === 'm3u';

            document.getElementById('modal-title').textContent = isNewznab ? 'Edit Newznab Indexer' : 'Edit IPTV Source';
            document.getElementById('source-id').value = source.id;
            document.getElementById('source-name').value = source.name;
            document.getElementById('source-type').value = source.type;
            document.getElementById('source-url').value = source.url;

            // Show/hide appropriate fields
            document.getElementById('xtream-fields').style.display = source.type === 'xtream' ? 'block' : 'none';
            document.getElementById('newznab-fields').style.display = isNewznab ? 'block' : 'none';
            document.getElementById('iptv-fields').style.display = isIptv ? 'block' : 'none';

            if (isNewznab) {
                // Populate newznab fields
                const config = source.indexer_config ? JSON.parse(source.indexer_config) : {};
                document.getElementById('source-apikey').value = config.apiKey || '';
                // Reset all category checkboxes
                document.querySelectorAll('.newznab-cat').forEach(cb => {
                    cb.checked = (config.categories || [2000, 5000]).includes(parseInt(cb.value));
                });
            } else {
                // Populate IPTV fields
                document.getElementById('source-username').value = source.username || '';
                document.getElementById('source-password').value = source.password || '';
                document.getElementById('source-useragent').value = source.user_agent || 'IBOPlayer';
                document.getElementById('source-epg-url').value = source.epg_url || '';
                document.getElementById('source-mac').value = source.spoofed_mac || '';
                document.getElementById('source-devicekey').value = source.spoofed_device_key || '';
                // Player simulation settings (defaults if not set)
                const simulatePlayback = source.simulate_playback !== undefined ? source.simulate_playback : 1;
                const speedMultiplier = source.playback_speed_multiplier != null ? source.playback_speed_multiplier : 1.5;
                document.getElementById('source-simulate-playback').checked = simulatePlayback === 1;
                document.getElementById('source-playback-speed').value = String(speedMultiplier);
                document.getElementById('playback-speed-container').style.display = simulatePlayback === 1 ? 'block' : 'none';
            }

            document.getElementById('source-modal').classList.remove('hidden');
        } catch (err) {
            console.error('Failed to load source:', err);
            alert('Failed to load source');
        }
    }

    async function testSource() {
        const id = document.getElementById('source-id').value;
        const type = document.getElementById('source-type').value;

        try {
            let result;

            if (type === 'newznab') {
                // Test newznab indexer - can test without saving
                const categories = [];
                document.querySelectorAll('.newznab-cat:checked').forEach(cb => {
                    categories.push(parseInt(cb.value));
                });
                const source = {
                    url: document.getElementById('source-url').value,
                    indexer_config: JSON.stringify({
                        apiKey: document.getElementById('source-apikey').value,
                        categories: categories
                    })
                };
                const response = await fetch('/api/newznab/test', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(source)
                });
                result = await response.json();
                if (result.success) {
                    alert('Connected to ' + (result.serverName || 'indexer') + ' with ' + result.categories + ' categories available.');
                } else {
                    alert('Failed: ' + (result.error || 'Unknown error'));
                }
            } else if (id) {
                // Test existing IPTV source via API
                const response = await fetch('/api/sources/' + id + '/test', { method: 'POST' });
                result = await response.json();
                if (result.success) {
                    alert('Success: ' + result.message);
                } else {
                    alert('Failed: ' + result.message);
                }
            } else {
                // For new IPTV sources, we need to save first
                alert('Please save the source first, then test it.');
                return;
            }
        } catch (err) {
            console.error('Failed to test source:', err);
            alert('Failed to test source: ' + err.message);
        }
    }

    async function syncSource(id) {
        try {
            // Show progress UI
            const progressEl = document.getElementById('sync-progress-' + id);
            const btnEl = document.getElementById('sync-btn-' + id);
            if (progressEl) progressEl.classList.remove('hidden');
            if (btnEl) btnEl.disabled = true;

            await fetch('/api/sources/' + id + '/sync', { method: 'POST' });
        } catch (err) {
            console.error('Failed to sync source:', err);
            alert('Failed to start sync');
            // Hide progress on error
            const progressEl = document.getElementById('sync-progress-' + id);
            const btnEl = document.getElementById('sync-btn-' + id);
            if (progressEl) progressEl.classList.add('hidden');
            if (btnEl) btnEl.disabled = false;
        }
    }

    // Source Pattern Analyzer Functions
    let currentAnalyzerSourceId = null;
    let currentAnalyzerPatterns = null;
    let currentAnalyzerSamples = null;
    let currentSelection = null;

    async function analyzeSource(id) {
        currentAnalyzerSourceId = id;
        currentAnalyzerPatterns = { titlePatterns: {}, contentTypePatterns: {}, confidence: 0 };
        currentAnalyzerSamples = null;
        currentSelection = null;

        // Show modal with loading state
        const modal = document.getElementById('analyzer-modal');
        const loading = document.getElementById('analyzer-loading');
        const results = document.getElementById('analyzer-results');
        const applyBtn = document.getElementById('analyzer-apply-btn');

        loading.classList.remove('hidden');
        results.classList.add('hidden');
        applyBtn.disabled = true;
        modal.classList.remove('hidden');
        document.getElementById('analyzer-status').textContent = '';

        try {
            document.getElementById('analyzer-loading-text').textContent = 'Fetching samples from source...';

            const response = await fetch('/api/sources/' + id + '/analyze', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' }
            });

            if (!response.ok) {
                const error = await response.json();
                throw new Error(error.error || 'Analysis failed');
            }

            const data = await response.json();

            if (!data.success) {
                throw new Error(data.error || 'Analysis failed');
            }

            // Store samples and patterns
            currentAnalyzerSamples = data.samples;
            currentAnalyzerPatterns = data.patterns || { titlePatterns: {}, contentTypePatterns: {}, confidence: 0 };

            // Update counts
            document.getElementById('analyzer-movies-count').textContent = data.samples?.movieCount || 0;
            document.getElementById('analyzer-series-count').textContent = data.samples?.seriesCount || 0;
            document.getElementById('analyzer-live-count').textContent = data.samples?.livetvCount || 0;

            // Check for previously saved config first, then use detected patterns
            const savedConfig = data.savedConfig;
            const detectedPatterns = data.patterns;

            // Prefer saved patterns if available, otherwise use detected
            const langPattern = savedConfig?.titlePatterns?.language || detectedPatterns?.titlePatterns?.language || '';
            const yearPattern = savedConfig?.titlePatterns?.year || detectedPatterns?.titlePatterns?.year || '';
            const qualityPattern = savedConfig?.titlePatterns?.quality || detectedPatterns?.titlePatterns?.quality || '';
            const moviesPattern = savedConfig?.contentTypePatterns?.movies || detectedPatterns?.contentTypePatterns?.movies || '';
            const seriesPattern = savedConfig?.contentTypePatterns?.series || detectedPatterns?.contentTypePatterns?.series || '';

            // Fill pattern inputs
            document.getElementById('pattern-language').value = langPattern;
            document.getElementById('pattern-year').value = yearPattern;
            document.getElementById('pattern-quality').value = qualityPattern;
            document.getElementById('pattern-movies').value = moviesPattern;
            document.getElementById('pattern-series').value = seriesPattern;

            // Update current patterns
            currentAnalyzerPatterns.titlePatterns.language = langPattern;
            currentAnalyzerPatterns.titlePatterns.year = yearPattern;
            currentAnalyzerPatterns.titlePatterns.quality = qualityPattern;
            currentAnalyzerPatterns.contentTypePatterns.movies = moviesPattern;
            currentAnalyzerPatterns.contentTypePatterns.series = seriesPattern;

            // Render sample entries for visual editing
            renderSampleEntries();

            // Render preview with current patterns
            updatePreview();

            // Show results, hide loading
            loading.classList.add('hidden');
            results.classList.remove('hidden');
            applyBtn.disabled = false;

            const statusText = data.usedLLM ? 'AI patterns detected' : 'Patterns auto-detected';
            document.getElementById('analyzer-status').textContent = statusText;

            // Enable wizard mode
            enableWizardMode();

            if (window.showToast) {
                showToast('Pattern Wizard started! Follow the steps to configure your source.', 'success');
            }

        } catch (err) {
            console.error('Analysis failed:', err);
            document.getElementById('analyzer-loading-text').textContent = 'Failed: ' + err.message;

            if (window.showToast) {
                showToast('Analysis failed: ' + err.message, 'error');
            }
        }
    }

    function renderSampleEntries() {
        const container = document.getElementById('analyzer-samples');
        const allSamples = [
            ...(currentAnalyzerSamples?.movies || []).map(s => ({ ...s, type: 'Movie' })),
            ...(currentAnalyzerSamples?.series || []).map(s => ({ ...s, type: 'Series' })),
            ...(currentAnalyzerSamples?.livetv || []).map(s => ({ ...s, type: 'Live' }))
        ];

        container.innerHTML = allSamples.map((sample, idx) => \`
            <div class="p-3 hover:bg-dark-700/50 transition-colors">
                <div class="flex items-center gap-3">
                    <span class="px-2 py-0.5 rounded text-xs flex-shrink-0 \${
                        sample.type === 'Movie' ? 'bg-blue-500/20 text-blue-300' :
                        sample.type === 'Series' ? 'bg-green-500/20 text-green-300' :
                        'bg-orange-500/20 text-orange-300'
                    }">\${sample.type}</span>
                    <div class="flex-1 min-w-0">
                        <div class="sample-text text-sm text-white font-mono cursor-text select-text" data-idx="\${idx}" onmouseup="handleTextSelection(event, \${idx})">\${escapeHtml(sample.name)}</div>
                        <div class="text-xs text-dark-400 mt-0.5 truncate" title="\${escapeHtml(sample.category || '')}">\${sample.category || 'No category'}</div>
                    </div>
                </div>
            </div>
        \`).join('') || '<div class="p-4 text-center text-dark-400">No samples available</div>';
    }

    function escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text || '';
        return div.innerHTML;
    }

    function handleTextSelection(event, sampleIdx) {
        const selection = window.getSelection();
        const selectedText = selection.toString().trim();

        if (selectedText.length > 0) {
            currentSelection = {
                text: selectedText,
                sampleIdx: sampleIdx
            };
            showPatternContextMenu(event.clientX, event.clientY);
        } else {
            hidePatternContextMenu();
        }
    }

    function showPatternContextMenu(x, y) {
        const menu = document.getElementById('pattern-context-menu');
        menu.classList.remove('hidden');

        // Position menu
        const rect = menu.getBoundingClientRect();
        if (x + rect.width > window.innerWidth) x = window.innerWidth - rect.width - 10;
        if (y + rect.height > window.innerHeight) y = window.innerHeight - rect.height - 10;

        menu.style.left = x + 'px';
        menu.style.top = y + 'px';
    }

    function hidePatternContextMenu() {
        document.getElementById('pattern-context-menu').classList.add('hidden');
    }

    function markSelectionAs(type) {
        hidePatternContextMenu();

        if (!currentSelection || !currentSelection.text) return;

        const text = currentSelection.text;

        // Generate pattern based on selection
        if (type === 'language') {
            // Look for 2-3 letter codes
            const pattern = generateLanguagePattern(text);
            document.getElementById('pattern-language').value = pattern;
            currentAnalyzerPatterns.titlePatterns.language = pattern;
            document.getElementById('analyzer-status').textContent = 'Language pattern set: ' + text;
        } else if (type === 'year') {
            // Look for 4-digit years
            const pattern = generateYearPattern(text);
            document.getElementById('pattern-year').value = pattern;
            currentAnalyzerPatterns.titlePatterns.year = pattern;
            document.getElementById('analyzer-status').textContent = 'Year pattern set';
        } else if (type === 'quality') {
            // Quality indicators like 4K, HD, FHD
            const pattern = generateQualityPattern(text);
            document.getElementById('pattern-quality').value = pattern;
            currentAnalyzerPatterns.titlePatterns.quality = pattern;
            document.getElementById('analyzer-status').textContent = 'Quality pattern set: ' + text;
        } else if (type === 'title') {
            // Title is what remains after removing language and year
            document.getElementById('analyzer-status').textContent = 'Title marked (language/year will be removed)';
        } else if (type === 'ignore') {
            // Add to ignore pattern
            document.getElementById('analyzer-status').textContent = 'Pattern will be ignored';
        }

        currentSelection = null;
        window.getSelection().removeAllRanges();
        updatePreview();
    }

    function generateLanguagePattern(text) {
        // Find the full prefix including separators
        const allSamples = [
            ...(currentAnalyzerSamples?.movies || []),
            ...(currentAnalyzerSamples?.series || []),
            ...(currentAnalyzerSamples?.livetv || [])
        ];

        // Common separator patterns
        const separators = ['\\\\s*[★❖✦●◆▶►]\\\\s*', '\\\\s*[-:]\\\\s*', '\\\\s*[|/]\\\\s*', '\\\\s+'];

        for (const sep of separators) {
            const pattern = '^([A-Z]{2,3})' + sep;
            try {
                const regex = new RegExp(pattern, 'i');
                const matches = allSamples.filter(s => regex.test(s.name));
                if (matches.length >= 2) {
                    return pattern;
                }
            } catch (e) {}
        }

        // Fallback: just match what was selected
        return '^(' + text.replace(/[.*+?^$\{\}()|[\\]\\\\]/g, '\\\\$&') + ')\\\\s*';
    }

    function generateYearPattern(text) {
        const allSamples = [
            ...(currentAnalyzerSamples?.movies || []),
            ...(currentAnalyzerSamples?.series || []),
            ...(currentAnalyzerSamples?.livetv || [])
        ];

        // Common year patterns
        const patterns = [
            '[-–]\\\\s*(\\\\d{4})\\\\s*$',
            '\\\\(\\\\s*(\\\\d{4})\\\\s*\\\\)\\\\s*$',
            '\\\\[(\\\\d{4})\\\\]\\\\s*$',
            '\\\\s+(\\\\d{4})\\\\s*$'
        ];

        for (const pattern of patterns) {
            try {
                const regex = new RegExp(pattern);
                const matches = allSamples.filter(s => regex.test(s.name));
                if (matches.length >= 2) {
                    return pattern;
                }
            } catch (e) {}
        }

        // Fallback
        return '[-–]\\\\s*(\\\\d{4})\\\\s*$';
    }

    function generateQualityPattern(text) {
        // Normalize common quality indicators
        const normalizedText = text.toUpperCase().trim();

        // Map common formats to standard pattern
        const qualityMap = {
            '4K': '4K|UHD|2160p',
            'UHD': '4K|UHD|2160p',
            '2160P': '4K|UHD|2160p',
            '2K': '2K|1440p',
            '1440P': '2K|1440p',
            'FHD': 'FHD|1080p|1080i',
            '1080P': 'FHD|1080p|1080i',
            '1080I': 'FHD|1080p|1080i',
            'HD': 'HD|720p',
            '720P': 'HD|720p',
            'SD': 'SD|480p|576p',
            '480P': 'SD|480p|576p',
            '576P': 'SD|480p|576p'
        };

        // Find matching quality
        for (const [key, value] of Object.entries(qualityMap)) {
            if (normalizedText.includes(key)) {
                return '\\\\b(' + value + ')\\\\b';
            }
        }

        // Default: comprehensive quality pattern
        return '\\\\b(4K|UHD|2160p|2K|1440p|FHD|1080p|1080i|HD|720p|SD|480p|576p)\\\\b';
    }

    function autoDetectPatterns() {
        if (!currentAnalyzerSamples) return;

        document.getElementById('analyzer-status').textContent = 'Auto-detecting patterns...';

        const allNames = [
            ...(currentAnalyzerSamples.movies || []).map(s => s.name),
            ...(currentAnalyzerSamples.series || []).map(s => s.name),
            ...(currentAnalyzerSamples.livetv || []).map(s => s.name)
        ];

        // Detect language prefix
        const langPatterns = [
            { pattern: '^([A-Z]{2})\\\\s*[★❖✦●◆▶►]\\\\s*', name: 'Symbol separator' },
            { pattern: '^([A-Z]{2})\\\\s*[-:]\\\\s*', name: 'Dash/colon separator' },
            { pattern: '^\\\\[([A-Z]{2})\\\\]\\\\s*', name: 'Brackets' },
            { pattern: '^\\\\(([A-Z]{2})\\\\)\\\\s*', name: 'Parentheses' },
            { pattern: '^([A-Z]{2})\\\\s*[|/]\\\\s*', name: 'Pipe/slash separator' }
        ];

        for (const lp of langPatterns) {
            try {
                const regex = new RegExp(lp.pattern, 'i');
                const matches = allNames.filter(n => regex.test(n));
                if (matches.length >= 3) {
                    document.getElementById('pattern-language').value = lp.pattern;
                    currentAnalyzerPatterns.titlePatterns.language = lp.pattern;
                    break;
                }
            } catch (e) {}
        }

        // Detect year pattern
        const yearPatterns = [
            { pattern: '[-–]\\\\s*(\\\\d{4})\\\\s*$', name: 'Dash year' },
            { pattern: '\\\\(\\\\s*(\\\\d{4})\\\\s*\\\\)\\\\s*$', name: 'Parentheses year' },
            { pattern: '\\\\s+(\\\\d{4})\\\\s*$', name: 'Space year' }
        ];

        for (const yp of yearPatterns) {
            try {
                const regex = new RegExp(yp.pattern);
                const matches = allNames.filter(n => regex.test(n));
                if (matches.length >= 2) {
                    document.getElementById('pattern-year').value = yp.pattern;
                    currentAnalyzerPatterns.titlePatterns.year = yp.pattern;
                    break;
                }
            } catch (e) {}
        }

        // Detect quality pattern
        const qualityPattern = '\\\\b(4K|UHD|2160p|2K|1440p|FHD|1080p|1080i|HD|720p|SD|480p|576p)\\\\b';
        try {
            const regex = new RegExp(qualityPattern, 'i');
            const matches = allNames.filter(n => regex.test(n));
            if (matches.length >= 1) {
                document.getElementById('pattern-quality').value = qualityPattern;
                currentAnalyzerPatterns.titlePatterns.quality = qualityPattern;
            }
        } catch (e) {}

        // Detect content type keywords from categories
        const allCategories = [
            ...(currentAnalyzerSamples.movies || []).map(s => s.category).filter(c => c),
            ...(currentAnalyzerSamples.series || []).map(s => s.category).filter(c => c),
            ...(currentAnalyzerSamples.livetv || []).map(s => s.category).filter(c => c)
        ];

        const movieKw = allCategories.filter(c => /vod|movie|film|cinema/i.test(c));
        const seriesKw = allCategories.filter(c => /serie|show|season/i.test(c));

        if (movieKw.length > 0) {
            document.getElementById('pattern-movies').value = 'VOD|MOVIE|FILM';
            currentAnalyzerPatterns.contentTypePatterns.movies = 'VOD|MOVIE|FILM';
        }

        if (seriesKw.length > 0) {
            document.getElementById('pattern-series').value = 'SERIE|SHOW|SEASON';
            currentAnalyzerPatterns.contentTypePatterns.series = 'SERIE|SHOW|SEASON';
        }

        updatePreview();
        document.getElementById('analyzer-status').textContent = 'Patterns auto-detected. Review and adjust as needed.';
        if (window.showToast) showToast('Patterns auto-detected!', 'success');
    }

    async function aiDetectPatterns() {
        if (!currentAnalyzerSamples || !currentAnalyzerSourceId) return;

        document.getElementById('ai-detect-btn').disabled = true;
        document.getElementById('analyzer-status').textContent = 'Using AI to analyze patterns...';

        try {
            // Send more samples for better pattern detection (up to 15 of each type)
            const response = await fetch('/api/sources/' + currentAnalyzerSourceId + '/analyze-ai', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    samples: {
                        movies: currentAnalyzerSamples.movies?.slice(0, 15),
                        series: currentAnalyzerSamples.series?.slice(0, 15),
                        livetv: currentAnalyzerSamples.livetv?.slice(0, 15)
                    }
                })
            });

            if (!response.ok) {
                const err = await response.json();
                throw new Error(err.error || 'AI analysis failed');
            }

            const data = await response.json();

            if (data.patterns) {
                if (data.patterns.titlePatterns?.language) {
                    document.getElementById('pattern-language').value = data.patterns.titlePatterns.language;
                    currentAnalyzerPatterns.titlePatterns.language = data.patterns.titlePatterns.language;
                }
                if (data.patterns.titlePatterns?.year) {
                    document.getElementById('pattern-year').value = data.patterns.titlePatterns.year;
                    currentAnalyzerPatterns.titlePatterns.year = data.patterns.titlePatterns.year;
                }
                if (data.patterns.titlePatterns?.quality) {
                    document.getElementById('pattern-quality').value = data.patterns.titlePatterns.quality;
                    currentAnalyzerPatterns.titlePatterns.quality = data.patterns.titlePatterns.quality;
                }
                if (data.patterns.contentTypePatterns?.movies) {
                    document.getElementById('pattern-movies').value = data.patterns.contentTypePatterns.movies;
                    currentAnalyzerPatterns.contentTypePatterns.movies = data.patterns.contentTypePatterns.movies;
                }
                if (data.patterns.contentTypePatterns?.series) {
                    document.getElementById('pattern-series').value = data.patterns.contentTypePatterns.series;
                    currentAnalyzerPatterns.contentTypePatterns.series = data.patterns.contentTypePatterns.series;
                }
                // Store category cleanup patterns from AI
                if (data.patterns.categoryCleanup) {
                    currentAnalyzerPatterns.categoryCleanup = data.patterns.categoryCleanup;
                }
            }

            updatePreview();
            document.getElementById('analyzer-status').textContent = 'AI patterns detected';
            if (window.showToast) showToast('AI patterns detected!', 'success');

        } catch (err) {
            console.error('AI detection failed:', err);
            document.getElementById('analyzer-status').textContent = 'AI detection failed: ' + err.message;
            if (window.showToast) showToast('AI detection failed: ' + err.message, 'error');
        } finally {
            document.getElementById('ai-detect-btn').disabled = false;
        }
    }

    function clearPatternSelection() {
        document.getElementById('pattern-language').value = '';
        document.getElementById('pattern-year').value = '';
        document.getElementById('pattern-quality').value = '';
        document.getElementById('pattern-movies').value = '';
        document.getElementById('pattern-series').value = '';
        currentAnalyzerPatterns = { titlePatterns: {}, contentTypePatterns: {}, confidence: 0 };
        updatePreview();
        document.getElementById('analyzer-status').textContent = 'Patterns cleared';
    }

    function updatePreview() {
        const tbody = document.getElementById('analyzer-preview-body');
        const allSamples = [
            ...(currentAnalyzerSamples?.movies || []).map(s => ({ ...s, expectedType: 'Movie' })),
            ...(currentAnalyzerSamples?.series || []).map(s => ({ ...s, expectedType: 'Series' })),
            ...(currentAnalyzerSamples?.livetv || []).map(s => ({ ...s, expectedType: 'Live' }))
        ];

        const langPattern = document.getElementById('pattern-language').value;
        const yearPattern = document.getElementById('pattern-year').value;
        const qualityPattern = document.getElementById('pattern-quality').value;

        tbody.innerHTML = allSamples.map(sample => {
            let lang = '', year = '', quality = '';
            let cleanName = sample.name;

            // Extract language
            if (langPattern) {
                try {
                    const regex = new RegExp(langPattern, 'i');
                    const match = sample.name.match(regex);
                    if (match && match[1]) {
                        lang = match[1].toUpperCase();
                        cleanName = cleanName.replace(regex, '');
                    }
                } catch (e) {}
            }

            // Extract year
            if (yearPattern) {
                try {
                    const regex = new RegExp(yearPattern);
                    const match = sample.name.match(regex);
                    if (match && match[1]) {
                        year = match[1];
                        cleanName = cleanName.replace(regex, '');
                    }
                } catch (e) {}
            }

            // Extract quality
            if (qualityPattern) {
                try {
                    const regex = new RegExp(qualityPattern, 'i');
                    const match = sample.name.match(regex);
                    if (match && match[1]) {
                        quality = match[1].toUpperCase();
                        cleanName = cleanName.replace(new RegExp(qualityPattern, 'gi'), '');
                    }
                } catch (e) {}
            }

            // Clean up the name (using new RegExp with escaped backslashes to survive EJS processing)
            cleanName = cleanName.replace(new RegExp('^\\\\s*[-–:★❖]\\\\s*'), '').replace(new RegExp('\\\\s*[-–:★❖]\\\\s*$'), '').trim();
            cleanName = cleanName.replace(new RegExp('\\\\s+', 'g'), ' ').trim();

            // Clean category using AI patterns if available, otherwise keep original
            let cleanCategory = sample.category || '';

            // Apply AI category cleanup patterns if available
            if (currentAnalyzerPatterns.categoryCleanup?.removePatterns) {
                for (const pattern of currentAnalyzerPatterns.categoryCleanup.removePatterns) {
                    try {
                        const regex = new RegExp(pattern, 'gi');
                        cleanCategory = cleanCategory.replace(regex, '');
                    } catch (e) {}
                }
                cleanCategory = cleanCategory.trim();
            }

            // Try to extract language from category if not found in title
            if (!lang) {
                const countryToLang = {
                    'EN': 'EN', 'US': 'EN', 'UK': 'EN', 'GB': 'EN', 'AU': 'EN', 'CA': 'EN',
                    'ES': 'ES', 'MX': 'ES', 'FR': 'FR', 'BE': 'FR', 'DE': 'DE', 'AT': 'DE',
                    'IT': 'IT', 'PT': 'PT', 'BR': 'PT', 'NL': 'NL', 'RU': 'RU', 'PL': 'PL',
                    'TR': 'TR', 'JP': 'JP', 'KR': 'KR', 'CN': 'ZH', 'IN': 'HI',
                    'SE': 'SV', 'NO': 'NO', 'DK': 'DA', 'FI': 'FI', 'GR': 'EL',
                    'RO': 'RO', 'HU': 'HU', 'CZ': 'CS', 'SK': 'SK', 'RS': 'RS', 'BG': 'BG'
                };
                // Match 2-3 letter code at start of category (after optional symbols)
                const catText = (sample.category || '').replace(/^[^A-Za-z]+/, '');
                const langMatch = catText.match(/^([A-Z]{2,3})(?:\s|$|[^A-Za-z])/i);
                if (langMatch) {
                    const code = langMatch[1].toUpperCase();
                    if (countryToLang[code]) {
                        lang = countryToLang[code];
                    }
                }
            }

            // Quality badge color
            const qualityClass = quality.includes('4K') || quality.includes('UHD') ? 'bg-red-500/20 text-red-300' :
                                 quality.includes('FHD') || quality.includes('1080') ? 'bg-blue-500/20 text-blue-300' :
                                 quality.includes('HD') || quality.includes('720') ? 'bg-green-500/20 text-green-300' :
                                 quality ? 'bg-dark-500/50 text-dark-300' : '';

            return \`
                <tr class="border-b border-dark-700/50 hover:bg-dark-700/30">
                    <td class="p-2"><span class="px-2 py-0.5 rounded text-xs \${
                        sample.expectedType === 'Movie' ? 'bg-blue-500/20 text-blue-300' :
                        sample.expectedType === 'Series' ? 'bg-green-500/20 text-green-300' :
                        'bg-orange-500/20 text-orange-300'
                    }">\${sample.expectedType}</span></td>
                    <td class="p-2 font-mono text-xs" title="\${escapeHtml(sample.name)}">
                        <div class="truncate max-w-[300px]">\${escapeHtml(cleanName) || '-'}</div>
                    </td>
                    <td class="p-2 text-xs text-dark-400 truncate max-w-[120px]" title="\${escapeHtml(sample.category || '')}">\${escapeHtml(cleanCategory) || '-'}</td>
                    <td class="p-2 text-xs">\${year ? '<span class="text-green-400">' + year + '</span>' : '<span class="text-dark-500">-</span>'}</td>
                    <td class="p-2 text-xs">\${lang ? '<span class="text-purple-400">' + lang + '</span>' : '<span class="text-dark-500">-</span>'}</td>
                    <td class="p-2 text-xs">\${quality ? '<span class="px-1.5 py-0.5 rounded ' + qualityClass + '">' + quality + '</span>' : '<span class="text-dark-500">-</span>'}</td>
                </tr>
            \`;
        }).join('') || '<tr><td colspan="6" class="p-4 text-center text-dark-400">No samples</td></tr>';
    }

    async function fetchMoreSamples(type) {
        if (!currentAnalyzerSourceId) return;

        const btn = event.target;
        const originalText = btn.textContent;
        btn.textContent = 'Loading...';
        btn.disabled = true;

        try {
            const response = await fetch('/api/sources/' + currentAnalyzerSourceId + '/fetch-samples', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ type, count: 5 })
            });

            if (!response.ok) throw new Error('Failed to fetch samples');

            const data = await response.json();

            // Append new samples to existing ones
            if (data.samples) {
                if (type === 'movies' && data.samples.movies) {
                    currentAnalyzerSamples.movies = [...(currentAnalyzerSamples.movies || []), ...data.samples.movies];
                }
                if (type === 'series' && data.samples.series) {
                    currentAnalyzerSamples.series = [...(currentAnalyzerSamples.series || []), ...data.samples.series];
                }
                if (type === 'livetv' && data.samples.livetv) {
                    currentAnalyzerSamples.livetv = [...(currentAnalyzerSamples.livetv || []), ...data.samples.livetv];
                }

                // Update counts
                document.getElementById('analyzer-movies-count').textContent = currentAnalyzerSamples.movies?.length || 0;
                document.getElementById('analyzer-series-count').textContent = currentAnalyzerSamples.series?.length || 0;
                document.getElementById('analyzer-live-count').textContent = currentAnalyzerSamples.livetv?.length || 0;

                // Re-render
                renderSampleEntries();
                updatePreview();

                if (window.showToast) showToast('Added ' + (data.samples[type]?.length || 0) + ' ' + type + ' samples', 'success');
            }
        } catch (err) {
            console.error('Fetch samples error:', err);
            if (window.showToast) showToast('Failed to fetch samples: ' + err.message, 'error');
        } finally {
            btn.textContent = originalText;
            btn.disabled = false;
        }
    }

    function hideAnalyzerModal() {
        const modal = document.getElementById('analyzer-modal');
        modal.classList.add('hidden');
        hidePatternContextMenu();
        currentAnalyzerSourceId = null;
        currentAnalyzerPatterns = null;
        currentAnalyzerSamples = null;
        currentSelection = null;
        // Reset wizard state
        currentWizardStep = 1;
        wizardMode = false;
        document.getElementById('wizard-steps').classList.add('hidden');
        document.getElementById('legacy-buttons').classList.remove('hidden');
        document.getElementById('wizard-buttons').classList.add('hidden');
    }

    // ============================================================
    // Wizard Navigation Functions
    // ============================================================
    let currentWizardStep = 1;
    let wizardMode = false;
    let wizardEpgChannels = [];
    let wizardEpgSuggestions = {};

    function enableWizardMode() {
        wizardMode = true;
        currentWizardStep = 1;
        document.getElementById('wizard-steps').classList.remove('hidden');
        document.getElementById('legacy-buttons').classList.add('hidden');
        document.getElementById('wizard-buttons').classList.remove('hidden');
        updateWizardUI();
    }

    function updateWizardUI() {
        // Update step indicators
        document.querySelectorAll('.wizard-step').forEach((step, index) => {
            const stepNum = index + 1;
            const circle = step.querySelector('.wizard-step-circle');
            circle.classList.remove('active', 'completed');
            step.classList.remove('active');

            if (stepNum < currentWizardStep) {
                circle.classList.add('completed');
                circle.innerHTML = '<svg class="w-4 h-4" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"></path></svg>';
            } else if (stepNum === currentWizardStep) {
                circle.classList.add('active');
                step.classList.add('active');
                circle.textContent = stepNum;
            } else {
                circle.textContent = stepNum;
            }
        });

        // Update step lines
        document.querySelectorAll('.wizard-step-line').forEach((line, index) => {
            if (index < currentWizardStep - 1) {
                line.classList.add('completed');
            } else {
                line.classList.remove('completed');
            }
        });

        // Show/hide step content
        document.querySelectorAll('.wizard-step-content').forEach(content => {
            content.classList.remove('active');
            content.classList.add('hidden');
        });
        const stepContent = document.getElementById('wizard-step-' + currentWizardStep);
        if (stepContent) {
            stepContent.classList.add('active');
            stepContent.classList.remove('hidden');
        }

        // Update button visibility (3 steps total)
        document.getElementById('wizard-back-btn').style.display = currentWizardStep > 1 ? '' : 'none';
        document.getElementById('wizard-next-btn').classList.toggle('hidden', currentWizardStep >= 3);
        document.getElementById('wizard-skip-btn').classList.toggle('hidden', currentWizardStep >= 3);
        document.getElementById('wizard-finish-btn').classList.toggle('hidden', currentWizardStep < 3);

        // Load step-specific content
        if (currentWizardStep === 2) {
            loadEpgChannelsForWizard();
        } else if (currentWizardStep === 3) {
            updateReviewStep();
        }
    }

    function wizardNextStep() {
        if (currentWizardStep < 3) {
            currentWizardStep++;
            updateWizardUI();
        }
    }

    function wizardPrevStep() {
        if (currentWizardStep > 1) {
            currentWizardStep--;
            updateWizardUI();
        }
    }

    function wizardSkipStep() {
        wizardNextStep();
    }

    async function wizardFinish() {
        const reprocess = document.getElementById('wizard-reprocess').checked;

        if (reprocess) {
            await applyAndReprocess();
        } else {
            await applyAnalyzedPatterns();
        }
    }

    function updateReviewStep() {
        // Update pattern summary
        document.getElementById('review-lang-pattern').textContent =
            document.getElementById('pattern-language').value || 'Not set';
        document.getElementById('review-year-pattern').textContent =
            document.getElementById('pattern-year').value || 'Not set';
        document.getElementById('review-quality-pattern').textContent =
            document.getElementById('pattern-quality').value || 'Not set';
        document.getElementById('review-movies-pattern').textContent =
            document.getElementById('pattern-movies').value || 'Not set';
        document.getElementById('review-series-pattern').textContent =
            document.getElementById('pattern-series').value || 'Not set';

        // Update EPG stats
        const matched = wizardEpgChannels.filter(c => c.tvg_id).length;
        const unmatched = wizardEpgChannels.filter(c => !c.tvg_id).length;
        document.getElementById('review-epg-matched').textContent = matched;
        document.getElementById('review-epg-unmatched').textContent = unmatched;
    }

    // ============================================================
    // EPG Matching Functions for Wizard
    // ============================================================
    async function loadEpgChannelsForWizard() {
        if (!currentAnalyzerSourceId) return;

        const container = document.getElementById('epg-channels-list');
        container.innerHTML = '<p class="text-dark-400 text-center py-8">Loading channels...</p>';

        try {
            const response = await fetch('/api/sources/' + currentAnalyzerSourceId + '/channels?type=live');
            const data = await response.json();

            wizardEpgChannels = data.channels || [];
            renderEpgChannelsList();

            // Update stats
            const matched = wizardEpgChannels.filter(c => c.tvg_id).length;
            const unmatched = wizardEpgChannels.length - matched;
            document.getElementById('epg-matched-count').textContent = matched;
            document.getElementById('epg-unmatched-count').textContent = unmatched;
        } catch (err) {
            container.innerHTML = '<p class="text-red-400 text-center py-8">Failed to load channels: ' + err.message + '</p>';
        }
    }

    function renderEpgChannelsList() {
        const container = document.getElementById('epg-channels-list');
        const filter = document.getElementById('epg-filter').value;
        const search = (document.getElementById('epg-channel-search').value || '').toLowerCase();

        let channels = wizardEpgChannels;

        // Apply filters
        if (filter === 'matched') {
            channels = channels.filter(c => c.tvg_id);
        } else if (filter === 'unmatched') {
            channels = channels.filter(c => !c.tvg_id);
        }

        if (search) {
            channels = channels.filter(c => c.title.toLowerCase().includes(search));
        }

        if (channels.length === 0) {
            container.innerHTML = '<p class="text-dark-400 text-center py-8">No channels found</p>';
            return;
        }

        container.innerHTML = channels.slice(0, 100).map(channel => {
            const matchStatus = channel.tvg_id ?
                '<span class="epg-match-badge matched">Matched</span>' :
                '<span class="epg-match-badge unmatched">Unmatched</span>';

            return \`
                <div class="epg-channel-row" data-media-id="\${channel.id}">
                    <span class="epg-channel-name text-white">\${channel.title}</span>
                    \${matchStatus}
                    <input type="text" class="input input-sm text-xs w-48"
                        value="\${channel.tvg_id || ''}"
                        placeholder="EPG Channel ID"
                        onchange="updateEpgMapping(\${channel.id}, this.value)" />
                </div>
            \`;
        }).join('');

        if (channels.length > 100) {
            container.innerHTML += '<p class="text-dark-400 text-center py-2 text-xs">Showing first 100 of ' + channels.length + ' channels</p>';
        }
    }

    function filterEpgChannels(search) {
        renderEpgChannelsList();
    }

    function filterEpgChannelsByStatus(status) {
        renderEpgChannelsList();
    }

    async function updateEpgMapping(mediaId, epgChannelId) {
        try {
            await fetch('/api/media/' + mediaId, {
                method: 'PATCH',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ tvg_id: epgChannelId || null })
            });

            // Update local state
            const channel = wizardEpgChannels.find(c => c.id === mediaId);
            if (channel) {
                channel.tvg_id = epgChannelId || null;
            }

            // Update stats
            const matched = wizardEpgChannels.filter(c => c.tvg_id).length;
            const unmatched = wizardEpgChannels.length - matched;
            document.getElementById('epg-matched-count').textContent = matched;
            document.getElementById('epg-unmatched-count').textContent = unmatched;
        } catch (err) {
            console.error('Failed to update EPG mapping:', err);
        }
    }

    async function autoMatchEpgChannels() {
        const btn = document.getElementById('epg-auto-match-btn');
        const originalText = btn.innerHTML;
        btn.innerHTML = '<span class="animate-spin">⏳</span> Matching...';
        btn.disabled = true;

        try {
            const response = await fetch('/api/epg/match-channels', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ sourceId: currentAnalyzerSourceId })
            });

            if (response.ok) {
                await loadEpgChannelsForWizard();
                document.getElementById('analyzer-status').textContent = 'EPG channels auto-matched';
            }
        } catch (err) {
            document.getElementById('analyzer-status').textContent = 'Auto-match failed: ' + err.message;
        } finally {
            btn.innerHTML = originalText;
            btn.disabled = false;
        }
    }

    async function aiMatchEpgChannels() {
        const btn = document.getElementById('epg-ai-match-btn');
        const originalText = btn.innerHTML;
        btn.innerHTML = '<span class="animate-spin">⏳</span> AI Matching...';
        btn.disabled = true;

        try {
            const response = await fetch('/api/epg/match-channels', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ sourceId: currentAnalyzerSourceId, useAI: true })
            });

            if (response.ok) {
                await loadEpgChannelsForWizard();
                document.getElementById('analyzer-status').textContent = 'EPG channels AI-matched';
            }
        } catch (err) {
            document.getElementById('analyzer-status').textContent = 'AI match failed: ' + err.message;
        } finally {
            btn.innerHTML = originalText;
            btn.disabled = false;
        }
    }

    // Hide context menu on click outside
    document.addEventListener('click', (e) => {
        if (!e.target.closest('#pattern-context-menu') && !e.target.closest('.sample-text')) {
            hidePatternContextMenu();
        }
    });

    async function applyAnalyzedPatterns() {
        if (!currentAnalyzerSourceId || !currentAnalyzerPatterns) {
            alert('No patterns to apply');
            return;
        }

        // Get current values from inputs (user may have edited them)
        const patterns = {
            titlePatterns: {
                language: document.getElementById('pattern-language').value || null,
                year: document.getElementById('pattern-year').value || null,
                quality: document.getElementById('pattern-quality').value || null
            },
            contentTypePatterns: {
                movies: document.getElementById('pattern-movies').value || null,
                series: document.getElementById('pattern-series').value || null
            },
            confidence: currentAnalyzerPatterns.confidence
        };

        try {
            const response = await fetch('/api/sources/' + currentAnalyzerSourceId + '/apply-patterns', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ patterns })
            });

            if (!response.ok) {
                const error = await response.json();
                throw new Error(error.error || 'Failed to apply patterns');
            }

            hideAnalyzerModal();

            if (window.showToast) {
                showToast('Patterns applied successfully! The source will use these patterns on next sync.', 'success');
            }

        } catch (err) {
            console.error('Failed to apply patterns:', err);
            alert('Failed to apply patterns: ' + err.message);
        }
    }

    async function applyAndReprocess() {
        if (!currentAnalyzerSourceId) {
            alert('No source selected');
            return;
        }

        const btn = document.getElementById('analyzer-reprocess-btn');
        const statusEl = document.getElementById('analyzer-status');

        if (!confirm('This will save the current patterns and reprocess all entries using original titles. Continue?')) {
            return;
        }

        btn.disabled = true;

        try {
            // Step 1: Save patterns first
            statusEl.textContent = 'Saving patterns...';

            // Build patterns object from current inputs (user may have edited them)
            const patterns = {
                titlePatterns: {
                    language: document.getElementById('pattern-language').value || null,
                    year: document.getElementById('pattern-year').value || null,
                    quality: document.getElementById('pattern-quality').value || null
                },
                contentTypePatterns: {
                    movies: document.getElementById('pattern-movies').value || null,
                    series: document.getElementById('pattern-series').value || null
                },
                confidence: currentAnalyzerPatterns?.confidence || 0.5
            };

            // Include category cleanup patterns if available from AI
            if (currentAnalyzerPatterns?.categoryCleanup) {
                patterns.categoryCleanup = currentAnalyzerPatterns.categoryCleanup;
            }

            const saveResponse = await fetch('/api/sources/' + currentAnalyzerSourceId + '/apply-patterns', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ patterns })
            });

            if (!saveResponse.ok) {
                const error = await saveResponse.json();
                throw new Error(error.error || 'Failed to save patterns');
            }

            // Step 2: Reprocess all entries using original_title
            statusEl.textContent = 'Reprocessing all entries...';

            const reprocessResponse = await fetch('/api/sources/' + currentAnalyzerSourceId + '/reprocess', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' }
            });

            if (!reprocessResponse.ok) {
                const error = await reprocessResponse.json();
                throw new Error(error.error || 'Reprocessing failed');
            }

            const result = await reprocessResponse.json();
            statusEl.textContent = 'Patterns saved. Reprocessed ' + result.processed + ' of ' + result.total + ' entries';

            if (window.showToast) {
                showToast('Patterns saved and ' + result.processed + ' entries reprocessed', 'success');
            }

        } catch (err) {
            console.error('Apply & Reprocess failed:', err);
            statusEl.textContent = 'Failed: ' + err.message;
            if (window.showToast) showToast('Failed: ' + err.message, 'error');
        } finally {
            btn.disabled = false;
        }
    }

    async function syncSourceEpg(id) {
        try {
            // Show progress UI
            const progressEl = document.getElementById('epg-progress-' + id);
            const btnEl = document.getElementById('epg-btn-' + id);
            const statusEl = document.getElementById('epg-status-' + id);
            const barEl = document.getElementById('epg-bar-' + id);
            if (progressEl) progressEl.classList.remove('hidden');
            if (btnEl) btnEl.disabled = true;
            if (statusEl) statusEl.textContent = 'Starting EPG sync...';
            if (barEl) barEl.style.width = '0%';

            const response = await fetch('/api/sources/' + id + '/sync-epg', { method: 'POST' });
            const result = await response.json();

            if (result.success) {
                // API returns immediately, socket.io events will provide progress
                if (statusEl) statusEl.textContent = 'Downloading EPG data...';
            } else {
                throw new Error(result.error || 'EPG sync failed');
            }
        } catch (err) {
            console.error('Failed to sync EPG:', err);
            const statusEl = document.getElementById('epg-status-' + id);
            const progressEl = document.getElementById('epg-progress-' + id);
            const btnEl = document.getElementById('epg-btn-' + id);
            if (statusEl) statusEl.textContent = 'Failed: ' + err.message;
            if (window.showToast) {
                showToast('EPG sync failed: ' + err.message, 'error');
            }
            // Hide after 3 seconds on error
            setTimeout(() => {
                if (progressEl) progressEl.classList.add('hidden');
            }, 3000);
            if (btnEl) btnEl.disabled = false;
        }
        // Note: button is re-enabled by socket event handlers
    }

    async function fetchEpgStatus() {
        try {
            const response = await fetch('/api/epg/status');
            const statuses = await response.json();

            statuses.forEach(status => {
                const infoEl = document.getElementById('epg-info-' + status.source_id);
                if (infoEl && status.last_sync) {
                    infoEl.textContent = \`EPG: \${status.program_count} programs, \${status.channel_count} channels (last: \${new Date(status.last_sync).toLocaleString()})\`;
                }
            });
        } catch (err) {
            console.error('Failed to fetch EPG status:', err);
        }
    }

    // Socket listeners are now handled globally in app.js

    async function toggleSource(id) {
        try {
            const response = await fetch('/api/sources/' + id + '/toggle', { method: 'POST' });
            const result = await response.json();
            if (result.success) {
                // Reload sources to update UI
                loadSources();
            }
        } catch (err) {
            console.error('Failed to toggle source:', err);
        }
    }

    async function deleteSource(id) {
        if (!confirm('Delete this source and all its content?')) return;
        try {
            await fetch('/api/sources/' + id, { method: 'DELETE' });
            loadSources();
        } catch (err) {
            console.error('Failed to delete source:', err);
        }
    }

    async function testPlex() {
        try {
            const response = await fetch('/api/plex/libraries');
            const libraries = await response.json();
            if (libraries.length > 0) {
                alert('Plex connection successful! Found ' + libraries.length + ' libraries.');
            } else {
                alert('Connected but no libraries found.');
            }
        } catch (err) {
            alert('Failed to connect to Plex: ' + err.message);
        }
    }

    // =====================================================
    // HDHomeRun Emulator Functions
    // =====================================================

    async function loadHdhrStatus() {
        try {
            const response = await fetch('/api/hdhr/status');
            const status = await response.json();

            // Update status display
            const statusEl = document.getElementById('hdhr-status');
            const indicatorEl = document.getElementById('hdhr-status-indicator');
            const enabledEl = document.getElementById('setting-hdhrEnabled');

            if (status.running) {
                statusEl.textContent = 'Running on port ' + (status.port || 5004);
                indicatorEl.className = 'w-3 h-3 rounded-full bg-green-500';
            } else if (status.enabled) {
                statusEl.textContent = 'Enabled but not running';
                indicatorEl.className = 'w-3 h-3 rounded-full bg-yellow-500';
            } else {
                statusEl.textContent = 'Disabled';
                indicatorEl.className = 'w-3 h-3 rounded-full bg-dark-500';
            }

            if (enabledEl) {
                enabledEl.checked = status.enabled;
            }

            // Update URLs
            const epgUrlEl = document.getElementById('hdhr-epg-url');
            const lineupUrlEl = document.getElementById('hdhr-lineup-url');
            if (epgUrlEl && status.xmltvUrl) {
                epgUrlEl.textContent = status.xmltvUrl;
            }
            if (lineupUrlEl && status.baseUrl) {
                lineupUrlEl.textContent = status.baseUrl + '/lineup.json';
            }

            // Load channel count
            await loadHdhrChannelCount();
        } catch (err) {
            console.error('Failed to load HDHR status:', err);
        }
    }

    async function loadHdhrChannelCount() {
        try {
            const response = await fetch('/api/hdhr/channels');
            const channels = await response.json();
            const countEl = document.getElementById('hdhr-channel-count');
            if (countEl) {
                const count = Array.isArray(channels) ? channels.length : 0;
                countEl.textContent = count + ' channels';
            }
        } catch (err) {
            console.error('Failed to load HDHR channels:', err);
            const countEl = document.getElementById('hdhr-channel-count');
            if (countEl) countEl.textContent = '0 channels';
        }
    }

    async function toggleHdhr(enabled) {
        try {
            await fetch('/api/hdhr/toggle', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ enabled })
            });
            await loadHdhrStatus();
            if (window.showToast) {
                showToast(enabled ? 'HDHomeRun emulator enabled' : 'HDHomeRun emulator disabled', 'success');
            }
        } catch (err) {
            console.error('Failed to toggle HDHR:', err);
            if (window.showToast) {
                showToast('Failed to toggle HDHomeRun emulator', 'error');
            }
        }
    }

    async function openHdhrChannels() {
        const modal = document.getElementById('hdhr-channels-modal');
        modal.classList.remove('hidden');
        await loadHdhrCategories();
        await loadHdhrLineup();
    }

    function closeHdhrChannels() {
        const modal = document.getElementById('hdhr-channels-modal');
        modal.classList.add('hidden');
        loadHdhrChannelCount();
    }

    async function loadHdhrCategories() {
        try {
            const response = await fetch('/api/hdhr/categories');
            const categories = await response.json();
            const select = document.getElementById('hdhr-category-select');
            select.innerHTML = '<option value="">Select a category to add...</option>';
            categories.forEach(cat => {
                const opt = document.createElement('option');
                opt.value = cat.category;  // Use original category for matching
                opt.textContent = (cat.display_name || cat.category) + ' (' + cat.channel_count + ' channels)';
                select.appendChild(opt);
            });
        } catch (err) {
            console.error('Failed to load HDHR categories:', err);
        }
    }

    async function loadHdhrLineup() {
        try {
            const response = await fetch('/api/hdhr/channels');
            const channels = await response.json();
            const container = document.getElementById('hdhr-lineup');
            const countEl = document.getElementById('hdhr-lineup-count');

            countEl.textContent = channels.length;

            if (channels.length === 0) {
                container.innerHTML = '<p class="text-sm text-dark-400">No channels in lineup. Add a category above.</p>';
                return;
            }

            container.innerHTML = channels.map(function(ch) {
                return '<div class="flex items-center justify-between p-2 bg-dark-700 rounded">' +
                    '<div class="flex items-center gap-3">' +
                        '<span class="text-sm font-mono text-dark-400 w-8">' + ch.guide_number + '</span>' +
                        '<span class="text-sm text-white">' + (ch.guide_name || ch.title) + '</span>' +
                    '</div>' +
                    '<button onclick="removeHdhrChannel(' + ch.id + ')" class="text-red-400 hover:text-red-300">' +
                        '<svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">' +
                            '<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/>' +
                        '</svg>' +
                    '</button>' +
                '</div>';
            }).join('');
        } catch (err) {
            console.error('Failed to load HDHR lineup:', err);
        }
    }

    async function addHdhrCategory() {
        const select = document.getElementById('hdhr-category-select');
        const category = select.value;
        if (!category) {
            alert('Please select a category');
            return;
        }

        try {
            // Get current max channel number
            const channelsResp = await fetch('/api/hdhr/channels');
            const channels = await channelsResp.json();
            const startNumber = channels.length > 0
                ? Math.max(...channels.map(c => parseInt(c.guide_number) || 0)) + 1
                : 1;

            await fetch('/api/hdhr/categories/add', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ category, startNumber })
            });
            await loadHdhrLineup();
            select.value = '';
            if (window.showToast) {
                showToast('Category added to lineup', 'success');
            }
        } catch (err) {
            console.error('Failed to add category:', err);
            if (window.showToast) {
                showToast('Failed to add category', 'error');
            }
        }
    }

    async function removeHdhrChannel(id) {
        try {
            await fetch('/api/hdhr/channels/' + id, { method: 'DELETE' });
            await loadHdhrLineup();
        } catch (err) {
            console.error('Failed to remove channel:', err);
        }
    }

    async function clearHdhrChannels() {
        if (!confirm('Are you sure you want to clear all channels from the lineup?')) return;

        try {
            await fetch('/api/hdhr/channels', { method: 'DELETE' });
            await loadHdhrLineup();
            if (window.showToast) {
                showToast('Lineup cleared', 'success');
            }
        } catch (err) {
            console.error('Failed to clear channels:', err);
        }
    }

    async function rebuildHdhrLineup() {
        try {
            await fetch('/api/hdhr/lineup/rebuild', { method: 'POST' });
            await loadHdhrLineup();
            if (window.showToast) {
                showToast('Channels renumbered', 'success');
            }
        } catch (err) {
            console.error('Failed to rebuild lineup:', err);
        }
    }

    // Load HDHR status on page load
    loadHdhrStatus();

    document.getElementById('source-type').addEventListener('change', (e) => {
        const type = e.target.value;
        const isIptv = type === 'xtream' || type === 'm3u';
        document.getElementById('xtream-fields').style.display = type === 'xtream' ? 'block' : 'none';
        document.getElementById('newznab-fields').style.display = type === 'newznab' ? 'block' : 'none';
        document.getElementById('iptv-fields').style.display = isIptv ? 'block' : 'none';
        // Update modal title
        document.getElementById('modal-title').textContent = type === 'newznab' ? 'Add Newznab Indexer' : 'Add IPTV Source';
    });

    // Toggle speed multiplier visibility based on player simulation checkbox
    document.getElementById('source-simulate-playback').addEventListener('change', (e) => {
        document.getElementById('playback-speed-container').style.display = e.target.checked ? 'block' : 'none';
    });

    // TMDB Enrichment functions
    async function loadEnrichStats() {
        try {
            const response = await fetch('/api/enrich/stats');
            const stats = await response.json();
            const el = document.getElementById('enrich-stats');
            if (el) {
                el.textContent = stats.needsEnrichment + ' items need posters, ' + stats.enriched + ' enriched';
            }
        } catch (err) {
            console.error('Failed to load enrich stats:', err);
        }
    }

    function updateWorkerIndicators(count) {
        const container = document.getElementById('enrich-workers');
        if (!container) return;
        container.innerHTML = '';
        for (let i = 0; i < count; i++) {
            const dot = document.createElement('div');
            dot.className = 'w-3 h-3 rounded-full bg-primary-500 animate-pulse';
            dot.title = 'Worker ' + (i + 1);
            container.appendChild(dot);
        }
    }

    async function loadEnrichmentQueueStatus() {
        try {
            const response = await fetch('/api/enrich/queue');
            const result = await response.json();

            if (result.isRunning) {
                // Workers are running, show progress UI
                const btn = document.getElementById('enrich-btn');
                const stopBtn = document.getElementById('enrich-stop-btn');
                const progressDiv = document.getElementById('enrich-progress');
                const statusEl = document.getElementById('enrich-status');
                const rateEl = document.getElementById('enrich-rate');
                const pendingEl = document.getElementById('enrich-pending');
                const processingEl = document.getElementById('enrich-processing');
                const completedEl = document.getElementById('enrich-completed');
                const failedEl = document.getElementById('enrich-failed');
                const barEl = document.getElementById('enrich-bar');

                if (btn) btn.classList.add('hidden');
                if (stopBtn) stopBtn.classList.remove('hidden');
                if (progressDiv) progressDiv.classList.remove('hidden');

                const q = result.queue || {};
                const total = q.total || 1;
                const completed = (q.completed || 0) + (q.failed || 0);

                if (statusEl) statusEl.textContent = 'Enriching... ' + completed + '/' + total;
                if (rateEl) rateEl.textContent = (result.workers?.length || 4) + ' workers active';
                if (pendingEl) pendingEl.textContent = q.pending || 0;
                if (processingEl) processingEl.textContent = q.processing || 0;
                if (completedEl) completedEl.textContent = q.completed || 0;
                if (failedEl) failedEl.textContent = q.failed || 0;

                if (barEl && total > 0) {
                    barEl.style.width = Math.round((completed / total) * 100) + '%';
                }

                updateWorkerIndicators(result.workers?.length || 4);
            } else {
                // Workers not running, show start button
                const btn = document.getElementById('enrich-btn');
                const stopBtn = document.getElementById('enrich-stop-btn');
                const progressDiv = document.getElementById('enrich-progress');

                if (btn) btn.classList.remove('hidden');
                if (stopBtn) stopBtn.classList.add('hidden');
                if (progressDiv) progressDiv.classList.add('hidden');
            }
        } catch (err) {
            console.error('Failed to load enrichment queue status:', err);
        }
    }

    async function startEnrichment() {
        try {
            const btn = document.getElementById('enrich-btn');
            const stopBtn = document.getElementById('enrich-stop-btn');
            if (btn) btn.classList.add('hidden');
            if (stopBtn) stopBtn.classList.remove('hidden');

            const response = await fetch('/api/enrich/start', { method: 'POST' });
            const result = await response.json();
            if (!response.ok) {
                throw new Error(result.error || 'Failed to start enrichment');
            }
        } catch (err) {
            console.error('Failed to start enrichment:', err);
            if (window.showToast) showToast('Failed to start enrichment: ' + err.message, 'error');
            const btn = document.getElementById('enrich-btn');
            const stopBtn = document.getElementById('enrich-stop-btn');
            if (btn) btn.classList.remove('hidden');
            if (stopBtn) stopBtn.classList.add('hidden');
        }
    }

    async function stopEnrichment() {
        try {
            const response = await fetch('/api/enrich/stop', { method: 'POST' });
            const result = await response.json();
            if (!response.ok) {
                throw new Error(result.error || 'Failed to stop enrichment');
            }
            if (window.showToast) showToast('Enrichment stopped', 'info');
        } catch (err) {
            console.error('Failed to stop enrichment:', err);
            if (window.showToast) showToast('Failed to stop enrichment: ' + err.message, 'error');
        }
    }

    async function startOverseerrEnrichment() {
        try {
            const btn = document.getElementById('overseerr-enrich-btn');
            if (btn) btn.disabled = true;
            const response = await fetch('/api/enrich/overseerr', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ limit: 500 })
            });
            const result = await response.json();
            if (!response.ok) {
                throw new Error(result.error || 'Unknown error');
            }
        } catch (err) {
            console.error('Failed to start Overseerr enrichment:', err);
            alert('Failed to start Overseerr enrichment: ' + err.message);
            const btn = document.getElementById('overseerr-enrich-btn');
            if (btn) btn.disabled = false;
        }
    }

    // Per-source stats and enrichment
    async function loadSourceStats(sourceId) {
        try {
            const response = await fetch('/api/sources/' + sourceId + '/stats');
            const stats = await response.json();
            const el = document.getElementById('source-stats-' + sourceId);
            if (el) {
                el.innerHTML =
                    '<div><span class="text-dark-400">Movies</span><div class="text-white text-sm font-medium">' + stats.movies.toLocaleString() + '</div></div>' +
                    '<div><span class="text-dark-400">Series</span><div class="text-white text-sm font-medium">' + stats.series.toLocaleString() + '</div></div>' +
                    '<div><span class="text-dark-400">Live TV</span><div class="text-white text-sm font-medium">' + stats.live.toLocaleString() + '</div></div>' +
                    '<div><span class="text-dark-400">Downloads</span><div class="text-white text-sm font-medium">' + stats.downloaded.toLocaleString() + '</div></div>' +
                    '<div><span class="text-dark-400">Enriched</span><div class="text-white text-sm font-medium">' + stats.enriched.toLocaleString() + ' / ' + stats.total.toLocaleString() + '</div></div>';
            }
        } catch (err) {
            console.error('Failed to load source stats:', err);
            const el = document.getElementById('source-stats-' + sourceId);
            if (el) el.innerHTML = '<span class="text-dark-500 col-span-5">Failed to load stats</span>';
        }
    }

    async function enrichSource(sourceId) {
        try {
            const btn = document.getElementById('enrich-btn-' + sourceId);
            if (btn) btn.disabled = true;
            const response = await fetch('/api/sources/' + sourceId + '/enrich', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' }
            });
            const result = await response.json();
            if (!response.ok) {
                throw new Error(result.error || 'Unknown error');
            }
        } catch (err) {
            console.error('Failed to start source enrichment:', err);
            if (window.showToast) showToast('Failed to start enrichment: ' + err.message, 'error');
            const btn = document.getElementById('enrich-btn-' + sourceId);
            if (btn) btn.disabled = false;
        }
    }

    async function reprocessTitles(sourceId) {
        try {
            const btn = document.getElementById('reprocess-btn-' + sourceId);
            if (btn) {
                btn.disabled = true;
                btn.innerHTML = '<div class="animate-spin w-4 h-4 border-2 border-white border-t-transparent rounded-full"></div>';
            }

            const response = await fetch('/api/sources/' + sourceId + '/reprocess-titles', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' }
            });
            const result = await response.json();

            if (!response.ok) {
                throw new Error(result.error || 'Unknown error');
            }

            if (window.showToast) showToast('Cleaned ' + result.updated + ' titles', 'success');

            // Restore button
            if (btn) {
                btn.disabled = false;
                btn.innerHTML = '<svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 21a4 4 0 01-4-4V5a2 2 0 012-2h4a2 2 0 012 2v12a4 4 0 01-4 4zm0 0h12a2 2 0 002-2v-4a2 2 0 00-2-2h-2.343M11 7.343l1.657-1.657a2 2 0 012.828 0l2.829 2.829a2 2 0 010 2.828l-8.486 8.485M7 17h.01"></path></svg>';
            }
        } catch (err) {
            console.error('Failed to reprocess titles:', err);
            if (window.showToast) showToast('Failed to clean titles: ' + err.message, 'error');
            const btn = document.getElementById('reprocess-btn-' + sourceId);
            if (btn) {
                btn.disabled = false;
                btn.innerHTML = '<svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 21a4 4 0 01-4-4V5a2 2 0 012-2h4a2 2 0 012 2v12a4 4 0 01-4 4zm0 0h12a2 2 0 002-2v-4a2 2 0 00-2-2h-2.343M11 7.343l1.657-1.657a2 2 0 012.828 0l2.829 2.829a2 2 0 010 2.828l-8.486 8.485M7 17h.01"></path></svg>';
            }
        }
    }

    // Socket listeners for per-source events
    document.addEventListener('DOMContentLoaded', () => {
        // Per-source sync progress
        socket.on('sync:source:progress', (data) => {
            const progressEl = document.getElementById('sync-progress-' + data.sourceId);
            const statusEl = document.getElementById('sync-status-' + data.sourceId);
            const barEl = document.getElementById('sync-bar-' + data.sourceId);
            if (progressEl) progressEl.classList.remove('hidden');

            // Build status message with optional stats
            let msg = data.message || ('Syncing... ' + data.current + '/' + data.total);
            if (statusEl) statusEl.textContent = msg;

            // Use percent if available, otherwise calculate from current/total
            if (barEl) {
                if (data.percent !== undefined) {
                    barEl.style.width = data.percent + '%';
                } else if (data.total) {
                    barEl.style.width = Math.round((data.current / data.total) * 100) + '%';
                }
            }
        });

        socket.on('sync:source:complete', (data) => {
            const progressEl = document.getElementById('sync-progress-' + data.sourceId);
            const statusEl = document.getElementById('sync-status-' + data.sourceId);
            const barEl = document.getElementById('sync-bar-' + data.sourceId);
            const btnEl = document.getElementById('sync-btn-' + data.sourceId);

            // Show sync summary with stats if available
            if (data.stats && statusEl) {
                const s = data.stats;
                statusEl.textContent = 'Done: +' + s.added + ' new, ~' + s.updated + ' updated, -' + s.removed + ' removed';
                if (barEl) barEl.style.width = '100%';

                // Keep the summary visible for a few seconds
                setTimeout(() => {
                    if (progressEl) progressEl.classList.add('hidden');
                    loadSourceStats(data.sourceId);
                    loadSources();
                }, 4000);
            } else {
                if (progressEl) progressEl.classList.add('hidden');
                loadSourceStats(data.sourceId);
                loadSources();
            }

            if (btnEl) btnEl.disabled = false;
        });

        // Per-source enrichment progress
        socket.on('enrich:source:start', (data) => {
            const progressEl = document.getElementById('enrich-progress-' + data.sourceId);
            const statusEl = document.getElementById('enrich-status-' + data.sourceId);
            const barEl = document.getElementById('enrich-bar-' + data.sourceId);
            if (progressEl) progressEl.classList.remove('hidden');
            if (statusEl) statusEl.textContent = 'Starting enrichment... (0/' + data.total + ')';
            if (barEl) barEl.style.width = '0%';
        });

        socket.on('enrich:source:progress', (data) => {
            const statusEl = document.getElementById('enrich-status-' + data.sourceId);
            const barEl = document.getElementById('enrich-bar-' + data.sourceId);
            if (statusEl) statusEl.textContent = data.current + '/' + data.total + ' (' + data.success + ' enriched, ' + data.failed + ' not found)';
            if (barEl && data.total) barEl.style.width = Math.round((data.current / data.total) * 100) + '%';
        });

        socket.on('enrich:source:complete', (data) => {
            const progressEl = document.getElementById('enrich-progress-' + data.sourceId);
            const statusEl = document.getElementById('enrich-status-' + data.sourceId);
            const btnEl = document.getElementById('enrich-btn-' + data.sourceId);
            if (statusEl) statusEl.textContent = 'Complete: ' + data.success + ' enriched, ' + data.failed + ' not found';
            if (btnEl) btnEl.disabled = false;
            setTimeout(() => {
                if (progressEl) progressEl.classList.add('hidden');
                loadSourceStats(data.sourceId);
            }, 3000);
        });

        // Per-source download progress
        socket.on('download:source:progress', (data) => {
            const progressEl = document.getElementById('download-progress-' + data.sourceId);
            const titleEl = document.getElementById('download-title-' + data.sourceId);
            const barEl = document.getElementById('download-bar-' + data.sourceId);
            if (progressEl) progressEl.classList.remove('hidden');
            if (titleEl) titleEl.textContent = data.title || 'Downloading...';
            if (barEl) barEl.style.width = (data.percent || 0) + '%';
        });

        socket.on('download:source:complete', (data) => {
            const progressEl = document.getElementById('download-progress-' + data.sourceId);
            if (progressEl) {
                setTimeout(() => progressEl.classList.add('hidden'), 2000);
            }
            loadSourceStats(data.sourceId);
        });

        // EPG sync socket listeners
        socket.on('epg:start', (data) => {
            const statusEl = document.getElementById('epg-status-' + data.sourceId);
            const barEl = document.getElementById('epg-bar-' + data.sourceId);
            if (statusEl) statusEl.textContent = 'Downloading EPG data...';
            if (barEl) barEl.style.width = '0%';
        });

        socket.on('epg:progress', (data) => {
            const statusEl = document.getElementById('epg-status-' + data.sourceId);
            const barEl = document.getElementById('epg-bar-' + data.sourceId);
            if (statusEl) {
                statusEl.textContent = data.message || ('Inserting ' + (data.current || 0) + '/' + (data.total || 0) + ' programs...');
            }
            if (barEl && data.total > 0) {
                barEl.style.width = Math.round((data.current / data.total) * 100) + '%';
            }
        });

        socket.on('epg:complete', (data) => {
            const progressEl = document.getElementById('epg-progress-' + data.sourceId);
            const statusEl = document.getElementById('epg-status-' + data.sourceId);
            const btnEl = document.getElementById('epg-btn-' + data.sourceId);
            const barEl = document.getElementById('epg-bar-' + data.sourceId);
            if (statusEl) statusEl.textContent = 'Done: ' + (data.programCount || 0) + ' programs, ' + (data.channelCount || 0) + ' channels';
            if (barEl) barEl.style.width = '100%';
            if (btnEl) btnEl.disabled = false;
            if (window.showToast) {
                showToast('EPG sync complete!', 'success');
            }
            // Update EPG status display
            fetchEpgStatus();
            // Hide after 3 seconds
            setTimeout(() => {
                if (progressEl) progressEl.classList.add('hidden');
            }, 3000);
        });

        socket.on('epg:error', (data) => {
            const progressEl = document.getElementById('epg-progress-' + data.sourceId);
            const statusEl = document.getElementById('epg-status-' + data.sourceId);
            const btnEl = document.getElementById('epg-btn-' + data.sourceId);
            if (statusEl) statusEl.textContent = 'Failed: ' + (data.error || 'Unknown error');
            if (btnEl) btnEl.disabled = false;
            if (window.showToast) {
                showToast('EPG sync failed: ' + (data.error || 'Unknown error'), 'error');
            }
            // Hide after 3 seconds
            setTimeout(() => {
                if (progressEl) progressEl.classList.add('hidden');
            }, 3000);
        });
    });

    // =====================
    // Usenet Provider Functions
    // =====================

    async function loadUsenetProviders() {
        try {
            const response = await fetch('/api/usenet/providers');
            const providers = await response.json();
            const container = document.getElementById('usenet-providers-list');

            if (providers.length === 0) {
                container.innerHTML = '<p class="text-dark-500 text-sm">No providers configured. Add a usenet provider to download from Newznab indexers.</p>';
                return;
            }

            container.innerHTML = providers.map(function(p) {
                return '<div class="bg-dark-800 rounded-lg p-3 flex items-center justify-between">' +
                    '<div class="flex items-center gap-3">' +
                        '<div class="w-2 h-2 rounded-full ' + (p.enabled ? 'bg-green-500' : 'bg-dark-500') + '"></div>' +
                        '<div>' +
                            '<p class="text-white font-medium">' + p.name + '</p>' +
                            '<p class="text-xs text-dark-400">' + p.host + ':' + p.port + ' (' + p.connections + ' connections' + (p.ssl ? ', SSL' : '') + ')</p>' +
                        '</div>' +
                    '</div>' +
                    '<div class="flex gap-2">' +
                        '<button onclick="editUsenetProvider(' + p.id + ')" class="btn btn-secondary btn-sm">Edit</button>' +
                        '<button onclick="deleteUsenetProvider(' + p.id + ')" class="btn btn-danger btn-sm">Delete</button>' +
                    '</div>' +
                '</div>';
            }).join('');
        } catch (err) {
            console.error('Failed to load usenet providers:', err);
        }
    }

    function showAddUsenetProvider() {
        document.getElementById('usenet-modal-title').textContent = 'Add Usenet Provider';
        document.getElementById('usenet-provider-id').value = '';
        document.getElementById('usenet-name').value = '';
        document.getElementById('usenet-host').value = '';
        document.getElementById('usenet-port').value = '563';
        document.getElementById('usenet-username').value = '';
        document.getElementById('usenet-password').value = '';
        document.getElementById('usenet-connections').value = '10';
        document.getElementById('usenet-priority').value = '0';
        document.getElementById('usenet-ssl').checked = true;
        document.getElementById('usenet-provider-modal').classList.remove('hidden');
    }

    function hideUsenetModal() {
        document.getElementById('usenet-provider-modal').classList.add('hidden');
    }

    async function editUsenetProvider(id) {
        try {
            const response = await fetch('/api/usenet/providers');
            const providers = await response.json();
            const provider = providers.find(p => p.id === id);
            if (!provider) return alert('Provider not found');

            document.getElementById('usenet-modal-title').textContent = 'Edit Usenet Provider';
            document.getElementById('usenet-provider-id').value = provider.id;
            document.getElementById('usenet-name').value = provider.name;
            document.getElementById('usenet-host').value = provider.host;
            document.getElementById('usenet-port').value = provider.port;
            document.getElementById('usenet-username').value = provider.username || '';
            document.getElementById('usenet-password').value = '';
            document.getElementById('usenet-connections').value = provider.connections;
            document.getElementById('usenet-priority').value = provider.priority;
            document.getElementById('usenet-ssl').checked = provider.ssl === 1;
            document.getElementById('usenet-provider-modal').classList.remove('hidden');
        } catch (err) {
            console.error('Failed to load provider:', err);
            alert('Failed to load provider');
        }
    }

    async function saveUsenetProvider() {
        const id = document.getElementById('usenet-provider-id').value;
        const data = {
            name: document.getElementById('usenet-name').value,
            host: document.getElementById('usenet-host').value,
            port: parseInt(document.getElementById('usenet-port').value),
            username: document.getElementById('usenet-username').value,
            password: document.getElementById('usenet-password').value,
            connections: parseInt(document.getElementById('usenet-connections').value),
            priority: parseInt(document.getElementById('usenet-priority').value),
            ssl: document.getElementById('usenet-ssl').checked
        };

        try {
            const response = await fetch(id ? '/api/usenet/providers/' + id : '/api/usenet/providers', {
                method: id ? 'PUT' : 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(data)
            });
            if (!response.ok) {
                const errorData = await response.json().catch(() => ({}));
                throw new Error(errorData.error || 'Server returned ' + response.status);
            }
            hideUsenetModal();
            loadUsenetProviders();
        } catch (err) {
            console.error('Failed to save provider:', err);
            alert('Failed to save provider: ' + err.message);
        }
    }

    async function testUsenetProvider() {
        const id = document.getElementById('usenet-provider-id').value;
        if (!id) {
            alert('Please save the provider first, then test it.');
            return;
        }
        try {
            const response = await fetch('/api/usenet/providers/' + id + '/test', { method: 'POST' });
            const result = await response.json();
            if (result.success) {
                alert('Connection successful: ' + (result.message || 'Connected'));
            } else {
                alert('Connection failed: ' + (result.error || 'Unknown error'));
            }
        } catch (err) {
            alert('Test failed: ' + err.message);
        }
    }

    async function deleteUsenetProvider(id) {
        if (!confirm('Delete this usenet provider?')) return;
        try {
            await fetch('/api/usenet/providers/' + id, { method: 'DELETE' });
            loadUsenetProviders();
        } catch (err) {
            console.error('Failed to delete provider:', err);
            alert('Failed to delete provider');
        }
    }

    async function loadAuthStatus() {
        try {
            const response = await fetch('/api/auth/status');
            const data = await response.json();
            document.getElementById('auth-username').textContent = data.user?.username || 'Unknown';
            document.getElementById('auth-mfa-status').textContent = data.user?.totpEnabled ? 'Enabled' : 'Disabled';
            if (data.mfaEnabled === false) {
                const controls = document.getElementById('mfa-controls');
                const disable = document.getElementById('mfa-disable');
                const note = document.getElementById('mfa-disabled-note');
                if (controls) controls.classList.add('hidden');
                if (disable) disable.classList.add('hidden');
                if (note) note.classList.remove('hidden');
            }
        } catch (err) {
            console.error('Failed to load auth status:', err);
        }
    }

    async function setupTotp() {
        try {
            const response = await fetch('/api/auth/totp/setup', { method: 'POST' });
            const data = await response.json();
            if (!response.ok) throw new Error(data.error || 'Failed to generate secret');
            document.getElementById('totp-secret').value = data.secret || '';
            document.getElementById('totp-otpauth').value = data.otpauthUrl || '';
            if (data.qrDataUrl) {
                document.getElementById('totp-qr').src = data.qrDataUrl;
                document.getElementById('totp-qr-section').classList.remove('hidden');
            }
            if (window.showToast) showToast('TOTP secret generated', 'success');
        } catch (err) {
            console.error('Failed to setup TOTP:', err);
            if (window.showToast) showToast(err.message, 'error');
        }
    }

    async function enableTotp() {
        const token = document.getElementById('totp-token').value.trim();
        if (!token) {
            if (window.showToast) showToast('Enter the authenticator code', 'warning');
            return;
        }
        try {
            const response = await fetch('/api/auth/totp/enable', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ token })
            });
            const data = await response.json();
            if (!response.ok) throw new Error(data.error || 'Failed to enable MFA');
            document.getElementById('totp-token').value = '';
            document.getElementById('totp-qr-section').classList.add('hidden');
            document.getElementById('totp-qr').src = '';
            if (window.showToast) showToast('MFA enabled', 'success');
            loadAuthStatus();
        } catch (err) {
            console.error('Failed to enable MFA:', err);
            if (window.showToast) showToast(err.message, 'error');
        }
    }

    async function disableTotp() {
        const password = document.getElementById('mfa-disable-password').value;
        const token = document.getElementById('mfa-disable-token').value.trim();
        if (!password) {
            if (window.showToast) showToast('Enter your password', 'warning');
            return;
        }
        try {
            const response = await fetch('/api/auth/totp/disable', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ password, token })
            });
            const data = await response.json();
            if (!response.ok) throw new Error(data.error || 'Failed to disable MFA');
            document.getElementById('mfa-disable-password').value = '';
            document.getElementById('mfa-disable-token').value = '';
            document.getElementById('totp-qr-section').classList.add('hidden');
            document.getElementById('totp-qr').src = '';
            if (window.showToast) showToast('MFA disabled', 'success');
            loadAuthStatus();
        } catch (err) {
            console.error('Failed to disable MFA:', err);
            if (window.showToast) showToast(err.message, 'error');
        }
    }

    async function changePassword() {
        const currentPassword = document.getElementById('password-current').value;
        const newPassword = document.getElementById('password-new').value;
        if (!currentPassword || !newPassword) {
            if (window.showToast) showToast('Enter current and new passwords', 'warning');
            return;
        }
        try {
            const response = await fetch('/api/auth/password', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ currentPassword, newPassword })
            });
            const data = await response.json();
            if (!response.ok) throw new Error(data.error || 'Failed to update password');
            document.getElementById('password-current').value = '';
            document.getElementById('password-new').value = '';
            if (window.showToast) showToast('Password updated', 'success');
        } catch (err) {
            console.error('Failed to update password:', err);
            if (window.showToast) showToast(err.message, 'error');
        }
    }

    // Load usenet providers on page load
    loadUsenetProviders();
    loadAuthStatus();
</script>
` }) %>
