<%- include('layouts/main', { title: 'Series', body: `
<!-- Mini Hero with Featured Series -->
<section class="mini-hero" id="mini-hero">
    <div class="mini-hero-bg"></div>
    <div class="mini-hero-gradient"></div>
    <div class="mini-hero-content">
        <h1 class="text-4xl font-bold mb-2" id="hero-title">TV Series</h1>
        <p class="text-text-muted" id="hero-subtitle">Discover and watch TV shows from your library</p>
    </div>
</section>

<div class="content-container">
    <!-- Floating Filter Bar -->
    <div class="filter-bar">
        <div class="filter-bar-inner">
            <!-- Search -->
            <div class="filter-search">
                <svg class="filter-search-icon" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" />
                </svg>
                <input type="text" id="series-search-input" placeholder="Search series..." class="filter-search-input" />
            </div>

            <!-- Filter Chips -->
            <div class="filter-chips">
                <div class="filter-chip-group">
                    <select id="filter-quality" class="filter-select">
                        <option value="">Quality</option>
                        <option value="4K">4K</option>
                        <option value="1080p">1080p</option>
                        <option value="720p">720p</option>
                        <option value="SD">SD</option>
                    </select>
                </div>

                <div class="filter-chip-group">
                    <select id="filter-year" class="filter-select">
                        <option value="">Year</option>
                    </select>
                </div>

                <div class="filter-chip-group hidden lg:block">
                    <select id="filter-language" class="filter-select">
                        <option value="">Language</option>
                    </select>
                </div>

                <div class="filter-chip-group hidden lg:block">
                    <select id="filter-source" class="filter-select">
                        <option value="">Source</option>
                    </select>
                </div>

                <div class="filter-chip-group hidden xl:block">
                    <select id="filter-platform" class="filter-select">
                        <option value="">Category</option>
                    </select>
                </div>

                <div class="filter-chip-group hidden xl:block">
                    <select id="filter-genre" class="filter-select">
                        <option value="">Genre</option>
                    </select>
                </div>

                <div class="filter-chip-group">
                    <select id="filter-recently" class="filter-select">
                        <option value="">Time</option>
                        <option value="7">7 Days</option>
                        <option value="14">2 Weeks</option>
                        <option value="30">30 Days</option>
                    </select>
                </div>

                <div class="filter-chip-group">
                    <select id="sort-by" class="filter-select">
                        <option value="show_name">A-Z</option>
                        <option value="year">Year</option>
                        <option value="rating">Rating</option>
                        <option value="episode_count">Episodes</option>
                        <option value="created_at">New</option>
                    </select>
                </div>
            </div>

            <!-- Count -->
            <div class="filter-actions">
                <span class="result-count"><span id="results-count">0</span> shows</span>
            </div>
        </div>
    </div>

    <!-- Parse Button (if needed) -->
    <div id="parse-container" class="hidden mb-4">
        <button id="parse-btn" class="btn-hero-secondary">
            <svg class="w-5 h-5" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                <path stroke-linecap="round" stroke-linejoin="round" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"/>
            </svg>
            <span id="parse-btn-text">Parse Series</span>
        </button>
    </div>

    <!-- Grid View -->
    <div id="grid-view" class="grid-view">
        <div class="media-grid" id="series-grid"></div>

        <!-- Loading More Spinner -->
        <div class="mt-8 flex justify-center hidden" id="loading-more">
            <div class="flex items-center gap-3 text-text-muted">
                <div class="spinner"></div>
                <span>Loading more series...</span>
            </div>
        </div>
    </div>

    <!-- Empty State -->
    <div class="empty-state hidden" id="empty-state">
        <div class="empty-state-icon">
            <svg class="w-12 h-12" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="1.5">
                <path stroke-linecap="round" stroke-linejoin="round" d="M6 20.25h12m-7.5-3v3m3-3v3m-10.125-3h17.25c.621 0 1.125-.504 1.125-1.125V4.875c0-.621-.504-1.125-1.125-1.125H3.375c-.621 0-1.125.504-1.125 1.125v11.25c0 .621.504 1.125 1.125 1.125z" />
            </svg>
        </div>
        <p class="empty-state-title">No series found</p>
        <p class="empty-state-text">Try adjusting your search or filters</p>
    </div>
</div>

<script>
    let currentOffset = 0;
    const limit = 50;
    let loading = false;
    let hasMore = true;
    const STORAGE_KEY = 'hermes_series_filters';

    // Enrichment tracking
    const enrichingShows = new Set();
    let pendingEnrichment = [];
    let enrichmentTimer = null;

    function cleanShowName(name) {
        if (!name) return { title: '', year: null };
        let cleanTitle = name.replace(/^[A-Z]{2}\\s*-\\s*/, '');
        const yearMatch = cleanTitle.match(/\\((\\d{4})\\)/);
        let year = null;
        if (yearMatch) {
            year = parseInt(yearMatch[1]);
            cleanTitle = cleanTitle.replace(/\\s*\\(\\d{4}\\)/, '').trim();
        }
        cleanTitle = cleanTitle.replace(/\\s*\\([A-Z]{2}\\)/, '').trim();
        return { title: cleanTitle, year };
    }

    function queueForEnrichment(showName) {
        if (enrichingShows.has(showName)) return;
        pendingEnrichment.push(showName);
        enrichingShows.add(showName);
        if (enrichmentTimer) clearTimeout(enrichmentTimer);
        enrichmentTimer = setTimeout(processBatchEnrichment, 500);
    }

    async function processBatchEnrichment() {
        if (pendingEnrichment.length === 0) return;
        const showNames = [...pendingEnrichment];
        pendingEnrichment = [];
        try {
            const response = await fetch('/api/enrich/shows', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ showNames, highPriority: false })
            });
            const result = await response.json();
            if (result.results) {
                for (const item of result.results) {
                    if (item.success && item.showName) updateCardUI(item.showName, item);
                }
            }
        } catch (err) { console.error('Batch enrichment failed:', err); }
    }

    function updateCardUI(showName, data) {
        const card = document.querySelector('[data-show-name="' + CSS.escape(showName) + '"]');
        if (!card) return;
        if (data.poster && data.poster.includes('image.tmdb.org')) {
            const img = card.querySelector('img');
            if (img && !img.src.includes('image.tmdb.org')) {
                img.src = proxyImage(data.poster);
                img.classList.remove('lazy-image');
            }
        }
    }

    function saveFilters() {
        const filters = {
            quality: document.getElementById('filter-quality').value,
            year: document.getElementById('filter-year').value,
            language: document.getElementById('filter-language').value,
            source: document.getElementById('filter-source').value,
            platform: document.getElementById('filter-platform').value,
            genre: document.getElementById('filter-genre').value,
            recently: document.getElementById('filter-recently').value,
            sort: document.getElementById('sort-by').value
        };
        localStorage.setItem(STORAGE_KEY, JSON.stringify(filters));
    }

    function restoreFilters() {
        try {
            const urlParams = new URLSearchParams(window.location.search);
            const hasUrlParams = urlParams.has('quality') || urlParams.has('year') || urlParams.has('language') || urlParams.has('source') || urlParams.has('platform') || urlParams.has('genre') || urlParams.has('sort') || urlParams.has('recently');
            if (hasUrlParams) {
                if (urlParams.has('quality')) document.getElementById('filter-quality').value = urlParams.get('quality');
                if (urlParams.has('year')) document.getElementById('filter-year').value = urlParams.get('year');
                if (urlParams.has('language')) document.getElementById('filter-language').value = urlParams.get('language');
                if (urlParams.has('source')) document.getElementById('filter-source').value = urlParams.get('source');
                if (urlParams.has('platform')) document.getElementById('filter-platform').value = urlParams.get('platform');
                if (urlParams.has('genre')) document.getElementById('filter-genre').value = urlParams.get('genre');
                if (urlParams.has('recently')) document.getElementById('filter-recently').value = urlParams.get('recently');
                if (urlParams.has('sort')) document.getElementById('sort-by').value = urlParams.get('sort');
                return;
            }
            const saved = localStorage.getItem(STORAGE_KEY);
            if (saved) {
                const filters = JSON.parse(saved);
                if (filters.quality) document.getElementById('filter-quality').value = filters.quality;
                if (filters.year) document.getElementById('filter-year').value = filters.year;
                if (filters.language) document.getElementById('filter-language').value = filters.language;
                if (filters.source) document.getElementById('filter-source').value = filters.source;
                if (filters.platform) document.getElementById('filter-platform').value = filters.platform;
                if (filters.genre) document.getElementById('filter-genre').value = filters.genre;
                if (filters.recently) document.getElementById('filter-recently').value = filters.recently;
                if (filters.sort) document.getElementById('sort-by').value = filters.sort;
            }
        } catch (err) { console.error('Failed to restore filters:', err); }
    }

    function createSeriesCard(show, index, isEager = false) {
        const cleaned = cleanShowName(show.show_name);
        const displayTitle = cleaned.title || show.show_name;
        const displayYear = show.year || cleaned.year;
        const imgSrc = show.poster ? proxyImage(show.poster) : '/static/img/no-poster.svg';

        return \`
            <a href="/series/\${encodeURIComponent(show.show_name)}" class="content-card" data-show-name="\${show.show_name}">
                <div class="card-poster">
                    <img src="\${isEager ? imgSrc : '/static/img/placeholder.svg'}"
                         data-src="\${imgSrc}"
                         alt="\${displayTitle}"
                         class="\${isEager ? '' : 'lazy-image'}"
                         loading="\${isEager ? 'eager' : 'lazy'}"
                         onerror="this.src='/static/img/no-poster.svg'" />
                    <span class="quality-badge">\${show.episode_count} ep\${show.episode_count > 1 ? 's' : ''}</span>
                    \${show.has_trailer ? \`<span class="trailer-badge" title="Trailer available">
                        <svg viewBox="0 0 24 24" fill="white"><path d="M23.498 6.186a3.016 3.016 0 0 0-2.122-2.136C19.505 3.545 12 3.545 12 3.545s-7.505 0-9.377.505A3.017 3.017 0 0 0 .502 6.186C0 8.07 0 12 0 12s0 3.93.502 5.814a3.016 3.016 0 0 0 2.122 2.136c1.871.505 9.376.505 9.376.505s7.505 0 9.377-.505a3.015 3.015 0 0 0 2.122-2.136C24 15.93 24 12 24 12s0-3.93-.502-5.814zM9.545 15.568V8.432L15.818 12l-6.273 3.568z"/></svg>
                    </span>\` : ''}
                    <div class="card-overlay">
                        <div class="play-btn">
                            <svg class="w-5 h-5" fill="currentColor" viewBox="0 0 20 20">
                                <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM9.555 7.168A1 1 0 008 8v4a1 1 0 001.555.832l3-2a1 1 0 000-1.664l-3-2z" clip-rule="evenodd"/>
                            </svg>
                        </div>
                        <button class="preview-btn-card" onclick="event.preventDefault(); event.stopPropagation(); window.location.href='/series/\${encodeURIComponent(show.show_name)}#episodes'" title="View Episodes">
                            <svg fill="currentColor" viewBox="0 0 24 24"><path d="M8 5v14l11-7z"/></svg>
                        </button>
                    </div>
                </div>
                <div class="card-info">
                    <h3 class="card-title">\${displayTitle}</h3>
                    <p class="card-meta">
                        \${displayYear || ''}
                        \${show.rating ? \`<span class="flex items-center gap-0.5">
                            <svg class="w-3 h-3 text-yellow-400" fill="currentColor" viewBox="0 0 20 20">
                                <path d="M9.049 2.927c.3-.921 1.603-.921 1.902 0l1.07 3.292a1 1 0 00.95.69h3.462c.969 0 1.371 1.24.588 1.81l-2.8 2.034a1 1 0 00-.364 1.118l1.07 3.292c.3.921-.755 1.688-1.54 1.118l-2.8-2.034a1 1 0 00-1.175 0l-2.8 2.034c-.784.57-1.838-.197-1.539-1.118l1.07-3.292a1 1 0 00-.364-1.118L2.98 8.72c-.783-.57-.38-1.81.588-1.81h3.461a1 1 0 00.951-.69l1.07-3.292z"/></svg>
                            \${show.rating.toFixed(1)}
                        </span>\` : ''}
                        \${show.season_count ? \`<span>\${show.season_count}S</span>\` : ''}
                    </p>
                </div>
            </a>
        \`;
    }

    async function checkParseStatus() {
        try {
            const response = await fetch('/api/series/parse/stats');
            const stats = await response.json();

            if (stats.unparsed > 0) {
                document.getElementById('parse-container').classList.remove('hidden');
                document.getElementById('parse-btn-text').textContent = 'Parse ' + stats.unparsed.toLocaleString() + ' Series';
            }
        } catch (err) { console.error('Failed to check parse status:', err); }
    }

    async function parseSeries() {
        const parseBtn = document.getElementById('parse-btn');
        parseBtn.disabled = true;
        parseBtn.querySelector('span').textContent = 'Parsing...';

        try {
            const response = await fetch('/api/series/parse', { method: 'POST' });
            const result = await response.json();

            if (result.success) {
                parseBtn.querySelector('span').textContent = 'Done!';
                if (window.showToast) showToast('Parsed ' + result.updated.toLocaleString() + ' series', 'success');
                setTimeout(() => {
                    document.getElementById('parse-container').classList.add('hidden');
                    loadShows(true);
                }, 2000);
            }
        } catch (err) {
            parseBtn.querySelector('span').textContent = 'Error';
            if (window.showToast) showToast(err.message, 'error');
        }
    }

    async function loadShows(reset = false) {
        if (loading) return;
        loading = true;

        if (reset) {
            currentOffset = 0;
            hasMore = true;
        }

        const recentlyVal = document.getElementById('filter-recently').value;
        const params = new URLSearchParams({
            search: document.getElementById('series-search-input').value,
            quality: document.getElementById('filter-quality').value,
            year: document.getElementById('filter-year').value,
            language: document.getElementById('filter-language').value,
            source: document.getElementById('filter-source').value,
            platform: document.getElementById('filter-platform').value,
            genre: document.getElementById('filter-genre').value,
            sort: document.getElementById('sort-by').value,
            order: document.getElementById('sort-by').value === 'show_name' ? 'asc' : 'desc',
            limit,
            offset: currentOffset
        });
        if (recentlyVal) params.set('recently_added', recentlyVal);

        try {
            const response = await fetch('/api/shows?' + params);
            const data = await response.json();
            const shows = data.items || data;
            const totalCount = data.total;

            const grid = document.getElementById('series-grid');
            const emptyState = document.getElementById('empty-state');

            if (reset) grid.innerHTML = '';

            if (shows.length === 0 && currentOffset === 0) {
                emptyState.classList.remove('hidden');
                document.getElementById('grid-view').classList.add('hidden');
            } else {
                emptyState.classList.add('hidden');
                document.getElementById('grid-view').classList.remove('hidden');

                shows.forEach((show, index) => {
                    const isEager = currentOffset === 0 && index < 12;
                    grid.innerHTML += createSeriesCard(show, index, isEager);
                    if (!show.tmdb_id && index < 20) queueForEnrichment(show.show_name);
                });

                initLazyLoad();
            }

            // Update hero with first show
            if (reset && shows.length > 0) {
                const featured = shows.find(s => s.backdrop_url || s.poster) || shows[0];
                updateMiniHero(featured);
            }

            document.getElementById('results-count').textContent = (totalCount !== undefined ? totalCount : shows.length).toLocaleString();
            hasMore = shows.length === limit;
            if (hasMore) currentOffset += limit;
            document.getElementById('loading-more').classList.add('hidden');
        } catch (err) {
            console.error('Failed to load shows:', err);
        }

        loading = false;
    }

    function updateMiniHero(show) {
        const hero = document.getElementById('mini-hero');
        const bgUrl = show.backdrop_url || show.poster;
        if (bgUrl) {
            hero.querySelector('.mini-hero-bg').style.backgroundImage = 'url(' + proxyImage(bgUrl) + ')';
        }
    }

    async function loadFilters() {
        try {
            const [filtersResp, platformsResp] = await Promise.all([
                fetch('/api/filters'),
                fetch('/api/platforms?type=series')
            ]);
            const filters = await filtersResp.json();
            const platforms = await platformsResp.json();

            const yearSelect = document.getElementById('filter-year');
            filters.years.forEach(year => {
                yearSelect.innerHTML += \`<option value="\${year}">\${year}</option>\`;
            });

            const langSelect = document.getElementById('filter-language');
            filters.languages.forEach(lang => {
                if (lang) langSelect.innerHTML += \`<option value="\${lang}">\${lang}</option>\`;
            });

            const sourceSelect = document.getElementById('filter-source');
            if (filters.sources) {
                filters.sources.forEach(source => {
                    if (source.name) sourceSelect.innerHTML += \`<option value="\${source.id}">\${source.name}</option>\`;
                });
            }

            const platformSelect = document.getElementById('filter-platform');
            platforms.forEach(p => {
                if (p.platform) platformSelect.innerHTML += \`<option value="\${p.platform}">\${p.platform}</option>\`;
            });

            const genreSelect = document.getElementById('filter-genre');
            if (filters.genres) {
                filters.genres.forEach(genre => {
                    if (genre) genreSelect.innerHTML += \`<option value="\${genre}">\${genre}</option>\`;
                });
            }
        } catch (err) { console.error('Failed to load filters:', err); }
    }

    // Event listeners
    document.getElementById('series-search-input').addEventListener('input', debounce(() => loadShows(true), 300));
    ['filter-quality', 'filter-year', 'filter-language', 'filter-source', 'filter-platform', 'filter-genre', 'filter-recently', 'sort-by'].forEach(id => {
        document.getElementById(id).addEventListener('change', () => { saveFilters(); loadShows(true); });
    });
    document.getElementById('parse-btn').addEventListener('click', parseSeries);

    // Infinite scroll
    window.addEventListener('scroll', () => {
        if (loading || !hasMore) return;
        if (window.scrollY + window.innerHeight >= document.documentElement.scrollHeight - 500) {
            document.getElementById('loading-more').classList.remove('hidden');
            loadShows(false);
        }
    });

    // Initialize
    checkParseStatus();
    loadFilters().then(() => {
        restoreFilters();
        loadShows(true);
    });

    function debounce(func, wait) {
        let timeout;
        return (...args) => { clearTimeout(timeout); timeout = setTimeout(() => func(...args), wait); };
    }
</script>
` }) %>
